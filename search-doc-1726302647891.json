{"searchDocs":[{"title":"Package aliases","type":0,"sectionRef":"#","url":"/docs/dependencies/aliases","content":"","keywords":"","version":"Next"},{"title":"Giving a package an alias​","type":1,"pageTitle":"Package aliases","url":"/docs/dependencies/aliases#giving-a-package-an-alias","content":" When we left our lodash example we had version 4.17.21 published to the URLhttps://eik.store.com/npm/lodash/4.17.21/index.js.  The alias command in the Eik CLIcreates a URL that redirects to a specific version of a library.  eik login --key YOUR_EIK_KEY --server https://eik.store.com eik npm-alias lodash 4.17.21 4 --server https://eik.store.com   Let's break down the alias command a bit.  Its first argument lodash is the name from eik.json.The second argument 4.17.21 is the version we want to alias.The third argument 4 is the alias we want to create or update.  The --server argument lets you run the login and alias commands without having eik.json in the current directory.  Now you should be able to go to https://eik.store.com/npm/lodash/v4/index.js, and your browser should be redirected to the version you aliased.  ","version":"Next","tagName":"h2"},{"title":"Updating an alias​","type":1,"pageTitle":"Package aliases","url":"/docs/dependencies/aliases#updating-an-alias","content":" We saw how to update a shared dependency, so let's see how to update an alias as well.  Make a note of the new version you want your alias to point to. Then log in, and run the alias command with the new version number.  eik login --key YOUR_EIK_KEY --server https://eik.store.com eik npm-alias lodash 4.18.0 4 --server https://eik.store.com   ","version":"Next","tagName":"h2"},{"title":"Next steps​","type":1,"pageTitle":"Package aliases","url":"/docs/dependencies/aliases#next-steps","content":" Now that you've seen how to make aliases it's time to gather up your shared dependencies in import maps so they're easier to use. ","version":"Next","tagName":"h2"},{"title":"Import maps","type":0,"sectionRef":"#","url":"/docs/dependencies/import-maps","content":"","keywords":"","version":"Next"},{"title":"Create an import map​","type":1,"pageTitle":"Import maps","url":"/docs/dependencies/import-maps#create-an-import-map","content":" In the previous chapter you made an alias for lodash so applications can share the same major version and get automatic updates when the Eik alias is updated.  https://eik.store.com/npm/lodash/v4/index.js   Let's put that alias URL in an import map.  Eik import maps use the same syntax as import maps in the browser, though without the &lt;script&gt; tag.  { &quot;imports&quot;: { &quot;lodash&quot;: &quot;https://eik.store.com/npm/lodash/v4/index.js&quot; } }   Save that JSON to a file, for example map.json.  ","version":"Next","tagName":"h2"},{"title":"Publish the import map to Eik​","type":1,"pageTitle":"Import maps","url":"/docs/dependencies/import-maps#publish-the-import-map-to-eik","content":" Open a terminal window, log in, and run the eik map command.  eik login --key YOUR_EIK_KEY --server https://eik.store.com eik map store 1.0.0 ./map.json --server https://eik.store.com   You should now see the published import map at https://eik.store.com/map/store/1.0.0/.  ","version":"Next","tagName":"h3"},{"title":"Create an alias for the import map​","type":1,"pageTitle":"Import maps","url":"/docs/dependencies/import-maps#create-an-alias-for-the-import-map","content":" We encourage using aliases for import maps, similar to dependencies. That way an import map can be updated on Eik and new builds that use the import map get the updated map without changing their configuration.  eik login --key YOUR_EIK_KEY --server https://eik.store.com eik map-alias store 1.0.0 1 --server https://eik.store.com   After running the map-alias command you should see the import map at https://eik.store.com/map/store/v1/.  ","version":"Next","tagName":"h3"},{"title":"Update your import map​","type":1,"pageTitle":"Import maps","url":"/docs/dependencies/import-maps#update-your-import-map","content":" Say you add a new dependency and want to include it in the import map. The workflow is similar to when you first created the import map.  Update map.json to include the new mapping.  { &quot;imports&quot;: { &quot;date-fns&quot;: &quot;https://eik.store.com/npm/date-fns/v3/index.js&quot;, &quot;lodash&quot;: &quot;https://eik.store.com/npm/lodash/v4/index.js&quot; } }   Publish the map under a new version number.  eik login --key YOUR_EIK_KEY --server https://eik.store.com eik map store 1.1.0 ./map.json --server https://eik.store.com   ","version":"Next","tagName":"h2"},{"title":"Update an import map alias​","type":1,"pageTitle":"Import maps","url":"/docs/dependencies/import-maps#update-an-import-map-alias","content":" With a new version of the map it's time to update the alias. The command is the same as before, only with an updated version number.  eik login --key YOUR_EIK_KEY --server https://eik.store.com eik map-alias store 1.1.0 1 --server https://eik.store.com   ","version":"Next","tagName":"h3"},{"title":"Use your new import map​","type":1,"pageTitle":"Import maps","url":"/docs/dependencies/import-maps#use-your-new-import-map","content":" Applications can now update their eik.json config to use the new import map. As long as their build tool is configured with an Eik plugin, that plugin will handle fetching the import map from the server and do the proper import mapping at build-time. Check out the Guides section for several examples.  { &quot;name&quot;: &quot;my-app&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;server&quot;: &quot;https://eik.store.com&quot;, &quot;files&quot;: &quot;./public&quot;, &quot;import-map&quot;: [&quot;https://eik.store.com/map/store/v1&quot;] }   ","version":"Next","tagName":"h2"},{"title":"How many import maps should you make?​","type":1,"pageTitle":"Import maps","url":"/docs/dependencies/import-maps#how-many-import-maps-should-you-make","content":" Should you have one import for all your shared dependencies, or should you have several? That's up to you.  Import maps are versioned and can be aliased the same as any other asset on Eik. If you need to update a major version of a dependency you can create a new major version of the import map. However, updating a major version of a map means your users have to update their configuration.  If you have a dependency that's only used by a subset of your applications, consider having a separate import map for that dependency and its ecosystem of related modules. That way any major changes in that import map don't needlessly affect applications that don't use that dependency.  Taken to its extreme, you could make an import map for each dependency. However, at that point developers could just as well configure their builds to use the package aliases directly, skipping the import maps entirely.  ","version":"Next","tagName":"h2"},{"title":"Next steps​","type":1,"pageTitle":"Import maps","url":"/docs/dependencies/import-maps#next-steps","content":" You've now covered all the different assets and aliases on Eik:  Application packagesShared npm packagesImport maps  Now it's time to point application developers to the Getting started guide and let them know they should use your new import map. ","version":"Next","tagName":"h2"},{"title":"Publishing to the images namespace","type":0,"sectionRef":"#","url":"/docs/dependencies/images","content":"","keywords":"","version":"Next"},{"title":"Preparing images for Eik​","type":1,"pageTitle":"Publishing to the images namespace","url":"/docs/dependencies/images#preparing-images-for-eik","content":" The image namespace on Eik works the same way as for application code. You will need:  some images to uploadan eik.json  ","version":"Next","tagName":"h2"},{"title":"Configure Eik​","type":1,"pageTitle":"Publishing to the images namespace","url":"/docs/dependencies/images#configure-eik","content":" The first step is to create an eik.json file.  eik init   Open the newly created eik.json and fill out the required fields.  { &quot;name&quot;: &quot;my-images&quot;, &quot;type&quot;: &quot;image&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;server&quot;: &quot;https://eik.store.com&quot;, &quot;files&quot;: &quot;./path/to/images/folder&quot; }   tip If your organisation doesn't have a running Eik server yet, hop on over to the server documentation.  The files key should be set to a directory containing image files to publish. Eik does not discriminate file types so if you wish to upload videos and other types of media, this will also work.  ","version":"Next","tagName":"h3"},{"title":"Publish the images​","type":1,"pageTitle":"Publishing to the images namespace","url":"/docs/dependencies/images#publish-the-images","content":" Let's update the &quot;files&quot; field in eik.json to include an images folder in our imaginary project.  { &quot;name&quot;: &quot;my-images&quot;, &quot;type&quot;: &quot;image&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;server&quot;: &quot;https://eik.store.com&quot;, &quot;files&quot;: &quot;./images/&quot; }   Now you can log in to the Eik server and publish, same as when publishing an application.  eik login --key YOUR_EIK_KEY eik publish   At this point your images should be available on the path https://eik.store.com/img/my-images/1.0.0.  tip You should keep package.json, eik.json and the build script in version control so you don't have to recreate this setup when there are updates.  ","version":"Next","tagName":"h3"},{"title":"Get information about a published package​","type":1,"pageTitle":"Publishing to the images namespace","url":"/docs/dependencies/images#get-information-about-a-published-package","content":" To view publish information, you can use the eik meta command.  eik meta my-images   ","version":"Next","tagName":"h2"},{"title":"Updating a published package​","type":1,"pageTitle":"Publishing to the images namespace","url":"/docs/dependencies/images#updating-a-published-package","content":" New versions of the image package need to be published to the Eik server, either manually or with automation like Renovate or Dependabot. Whether you choose to automate or have a manual process, these are the steps to update a module.  Add, remove or update images in your images directoryUpdate the version number in eik.jsonRun the build scriptPublish to the Eik server ","version":"Next","tagName":"h2"},{"title":"Browser import mapping","type":0,"sectionRef":"#","url":"/docs/guides/browser-importmap","content":"","keywords":"","version":"Next"},{"title":"Differences from build-time mapping​","type":1,"pageTitle":"Browser import mapping","url":"/docs/guides/browser-importmap#differences-from-build-time-mapping","content":"   Build-time import mapping happens on the developer machine (or on continuous integration services like GitHub Actions). The build step fetches import maps from the Eik server, and the built JavaScript and CSS assets have the mapped values hard-coded.    Browser import mapping, on the other hand, happens at runtime in the user's browser.  With this setup you don't need a build step or plugin in order to use Eik. Depending on your source code and target browsers you may skip the build step entirely, and upload source code directly.  Mind the bundling If you do use a build step, make sure you don't end up bundling the dependencies hosted on Eik.  ","version":"Next","tagName":"h2"},{"title":"Configure import maps​","type":1,"pageTitle":"Browser import mapping","url":"/docs/guides/browser-importmap#configure-import-maps","content":" The configuration in eik.json is the same whether you use build-time or browser import maps.  We'll be using the example import map we made in Import maps. The map looks like this, and is hosted on our imaginary Eik server at https://eik.store.com/map/store/v1.  { &quot;imports&quot;: { &quot;date-fns&quot;: &quot;https://eik.store.com/npm/date-fns/v3/index.js&quot;, &quot;lodash&quot;: &quot;https://eik.store.com/npm/lodash/v4/index.js&quot; } }   That import map is added to our eik.json like so.  { &quot;server&quot;: &quot;https://eik.store.com&quot;, &quot;name&quot;: &quot;my-app&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;files&quot;: &quot;./public&quot;, &quot;import-map&quot;: [&quot;https://eik.store.com/map/store/v1&quot;] }   ","version":"Next","tagName":"h2"},{"title":"Download maps from Eik​","type":1,"pageTitle":"Browser import mapping","url":"/docs/guides/browser-importmap#download-maps-from-eik","content":" To get updates and avoid duplication we want to download the maps from Eik rather than have them hard-coded in our app. @eik/node-client is a utility that helps with this.  Install @eik/node-client if you haven't already.  npm install @eik/node-client   Then create a new instance. Make sure to configure loadMaps: true. When you call the load function @eik/node-client reads your configuration and fetches the listed import maps from the Eik server. Read the maps using the maps function.  const eik = new Eik({ loadMaps: true, }); await eik.load(); const maps = eik.maps();   Now that the maps are loaded we can use them to build the import map we'll send to the browser.  ","version":"Next","tagName":"h2"},{"title":"Send import maps to the browser​","type":1,"pageTitle":"Browser import mapping","url":"/docs/guides/browser-importmap#send-import-maps-to-the-browser","content":" Since your configuration can include several import maps the result from eik.maps() is a list of import maps. In our example it looks like this.  [ { &quot;imports&quot;: { &quot;date-fns&quot;: &quot;https://eik.store.com/npm/date-fns/v3/index.js&quot;, &quot;lodash&quot;: &quot;https://eik.store.com/npm/lodash/v4/index.js&quot; } } ]   The list can be transformed to the import map that gets sent to browsers like so. The reduce function combines a list of import maps to one import map. In case of name collisions the last item wins.  const maps = eik.maps(); const combined = maps.reduce((map, acc) =&gt; ({ ...acc, ...map }), {}); const html = ` &lt;script type=&quot;importmap&quot;&gt; ${JSON.stringify(combined, null, 2)} &lt;/script&gt; `;   In the example above, html is a string that looks like this.  &lt;script type=&quot;importmap&quot;&gt; { &quot;imports&quot;: { &quot;date-fns&quot;: &quot;https://eik.store.com/npm/date-fns/v3/index.js&quot;, &quot;lodash&quot;: &quot;https://eik.store.com/npm/lodash/v4/index.js&quot; } } &lt;/script&gt;   Place the import map HTML before any other &lt;script&gt; that uses the import map in your server's response.  ","version":"Next","tagName":"h2"},{"title":"Update the import maps periodically​","type":1,"pageTitle":"Browser import mapping","url":"/docs/guides/browser-importmap#update-the-import-maps-periodically","content":" Using aliases, import maps can be updated without needing a configuration change, or even a redeploy.  To get updates without redeploying, set up an interval that calls load periodically. Make sure to call maps inside a request handler.  import Eik from &quot;@eik/node-client&quot;; import fastify from &quot;fastify&quot;; const app = fastify(); const eik = new Eik({ loadMaps: true, }); await eik.load(); const updateMaps = setInterval(async () =&gt; { await eik.load(); }, 1_200_000); // 20 minutes app.addHook(&quot;onClose&quot;, () =&gt; { clearInterval(updateMaps); }); app.get(&quot;/&quot;, async (req, reply) =&gt; { const maps = eik.maps(); const combined = maps.reduce((map, acc) =&gt; ({ ...acc, ...map }), {}); const html = ` &lt;script type=&quot;importmap&quot;&gt; ${JSON.stringify(combined, null, 2)} &lt;/script&gt; `; });  ","version":"Next","tagName":"h2"},{"title":"Package types","type":0,"sectionRef":"#","url":"/docs/dependencies/introduction","content":"","keywords":"","version":"Next"},{"title":"Eik package types​","type":1,"pageTitle":"Package types","url":"/docs/dependencies/introduction#eik-package-types","content":" It's worth mentioning at this stage that Eik differentiates between three types of packages:  npmmappackage  You'll see this distinction in eik.json and in the URL where your package gets published. Each package type has its own namespace. This is to avoid accidental naming collisions between, say, the npm module lit and the import map lit.  Application code should be published to the package namespace. This is also the default, if no other type is configured in eik.json.  ","version":"Next","tagName":"h2"},{"title":"Naming and versioning packages​","type":1,"pageTitle":"Package types","url":"/docs/dependencies/introduction#naming-and-versioning-packages","content":" Packages published to Eik should follow the npm module naming convention and Semantic Versioning. This applies to all namespaces, although semantic versioning is less relevant for application code.  ","version":"Next","tagName":"h2"},{"title":"Next steps​","type":1,"pageTitle":"Package types","url":"/docs/dependencies/introduction#next-steps","content":" Let's learn how to publish a package to the npm namespace on Eik. ","version":"Next","tagName":"h2"},{"title":"Using Eik with esbuild","type":0,"sectionRef":"#","url":"/docs/guides/esbuild","content":"","keywords":"","version":"Next"},{"title":"Getting started​","type":1,"pageTitle":"Using Eik with esbuild","url":"/docs/guides/esbuild#getting-started","content":" Install @eik/esbuild-plugin, and esbuild if you haven't already.  npm install --save-dev esbuild @eik/esbuild-plugin   ","version":"Next","tagName":"h2"},{"title":"Configure your build​","type":1,"pageTitle":"Using Eik with esbuild","url":"/docs/guides/esbuild#configure-your-build","content":" Create a build.js file or extend your existing build script to add the Eik plugin.  import * as eik from &quot;@eik/esbuild-plugin&quot;; import esbuild from &quot;esbuild&quot;; const options = /** @type {esbuild.BuildOptions}*/ ({ entryPoints: [&quot;./src/index.js&quot;], outdir: &quot;./public&quot;, format: &quot;esm&quot;, platform: &quot;browser&quot;, target: [&quot;es2017&quot;], bundle: true, sourcemap: true, }); const watch = process.argv.includes(&quot;--dev&quot;); if (watch) { let ctx = await esbuild.context(options); await ctx.watch(); console.log(&quot;[esbuild] watching...&quot;); } else { // Use the Eik plugin to to import mapping for the production build // Load the import maps listed in eik.json from the Eik server await eik.load(); await esbuild.build({ ...options, plugins: [eik.plugin()], }); }   ","version":"Next","tagName":"h2"},{"title":"Run your build​","type":1,"pageTitle":"Using Eik with esbuild","url":"/docs/guides/esbuild#run-your-build","content":" Add these scripts to package.json if you haven't already.  { &quot;scripts&quot;: { &quot;build&quot;: &quot;node ./build.js&quot;, &quot;dev&quot;: &quot;node ./build.js --dev&quot; } }   Now you can run a production build using the Eik plugin by running this command.  npm run build   ","version":"Next","tagName":"h2"},{"title":"Advanced usage​","type":1,"pageTitle":"Using Eik with esbuild","url":"/docs/guides/esbuild#advanced-usage","content":" See the plugin documentation for advanced options on loading import maps. ","version":"Next","tagName":"h2"},{"title":"Publishing to the npm namespace","type":0,"sectionRef":"#","url":"/docs/dependencies/npm","content":"","keywords":"","version":"Next"},{"title":"Preparing an npm module for Eik​","type":1,"pageTitle":"Publishing to the npm namespace","url":"/docs/dependencies/npm#preparing-an-npm-module-for-eik","content":" The npm namespace on Eik works the same way as for application code. Like you did when you prepared your application for Eik, you will need:  ESM code that can run in the browseran eik.json  Not all modules published to npm are ESM, and not all ES modules published to npm can run in the browser as-is. In other words, you will probably also need a build step.  ","version":"Next","tagName":"h2"},{"title":"Create a package​","type":1,"pageTitle":"Publishing to the npm namespace","url":"/docs/dependencies/npm#create-a-package","content":" First, let's get the module from npm. Create a new directory and add a package.json to it. Then install the module you want to share on the Eik server.  Let's use lodash as an example.  mkdir lodash cd lodash npm init -y npm install lodash   At this point your lodash/ folder should contain the following:  a node_modules directory containing the lodash modulepackage.json with lodash listed as a dependencypackage-lock.json  ","version":"Next","tagName":"h3"},{"title":"Configure Eik​","type":1,"pageTitle":"Publishing to the npm namespace","url":"/docs/dependencies/npm#configure-eik","content":" The next step is to create eik.json.  eik init   Open the newly created eik.json and fill out the required fields.  { &quot;name&quot;: &quot;lodash&quot;, &quot;type&quot;: &quot;npm&quot;, &quot;version&quot;: &quot;4.17.21&quot;, &quot;server&quot;: &quot;https://eik.store.com&quot;, &quot;files&quot;: {} }   tip If your organisation doesn't have a running Eik server yet, hop on over to the server documentation.  You should also use import maps if your dependency has dependencies of its own that are hosted on Eik.  Now, what to put in &quot;files&quot;? Technically there's nothing stopping you from pointing eik.json to files inside node_modules. If your dependency is ESM and ready to run in the browser, that's totally valid.  { &quot;name&quot;: &quot;my-dep&quot;, &quot;type&quot;: &quot;npm&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;server&quot;: &quot;https://eik.store.com&quot;, &quot;files&quot;: &quot;./node_modules/my-dep/dist/&quot; }   In many cases though, you're going to need a build step.  ","version":"Next","tagName":"h3"},{"title":"Build an ESM version​","type":1,"pageTitle":"Publishing to the npm namespace","url":"/docs/dependencies/npm#build-an-esm-version","content":" As with application code, you should build npm packages for Eik using a build tool with an Eik plugin so you can take advantage of import maps. In this example we'll be using esbuild with the Eik esbuild plugin.  npm install --save-dev esbuild @eik/esbuild-plugin   Create a new file build.js and configure esbuild to use the Eik plugin.  import { createRequire } from &quot;node:module&quot;; import * as eik from &quot;@eik/esbuild-plugin&quot;; import esbuild from &quot;esbuild&quot;; await eik.load(); const { resolve } = createRequire(import.meta.url); await esbuild.build({ plugins: [eik.plugin()], entryPoints: [resolve(&quot;lodash&quot;)], outfile: &quot;dist/index.js&quot;, target: [&quot;es2017&quot;], format: &quot;esm&quot;, bundle: true, minify: true, sourcemap: true, });   Add a build script to your package.json.  { &quot;name&quot;: &quot;lodash&quot;, &quot;type&quot;: &quot;module&quot;, &quot;private&quot;: true, &quot;scripts&quot;: { &quot;build&quot;: &quot;node build.js&quot; }, &quot;dependencies&quot;: { &quot;lodash&quot;: &quot;4.17.21&quot; }, &quot;devDependencies&quot;: { &quot;@eik/esbuild-plugin&quot;: &quot;1.1.47&quot;, &quot;esbuild&quot;: &quot;0.23.0&quot; } }   Now you can run npm run build and you should see a dist/ folder with some JavaScript.  ","version":"Next","tagName":"h3"},{"title":"Publish the built ESM​","type":1,"pageTitle":"Publishing to the npm namespace","url":"/docs/dependencies/npm#publish-the-built-esm","content":" Let's update the &quot;files&quot; field in eik.json to include the files we built.  { &quot;name&quot;: &quot;lodash&quot;, &quot;type&quot;: &quot;npm&quot;, &quot;version&quot;: &quot;4.17.21&quot;, &quot;server&quot;: &quot;https://eik.store.com&quot;, &quot;files&quot;: &quot;./dist/&quot; }   Now you can log in to the Eik server and publish, same as when publishing an application.  eik login --key YOUR_EIK_KEY eik publish   At this point the shared ESM version of lodash should be available on https://eik.store.com/npm/lodash/4.17.21/index.js.  tip You should keep package.json, eik.json and the build script in version control so you don't have to recreate this setup when there are updates.  ","version":"Next","tagName":"h3"},{"title":"Get information about a published package​","type":1,"pageTitle":"Publishing to the npm namespace","url":"/docs/dependencies/npm#get-information-about-a-published-package","content":" To view publish information, you can use the eik meta command.  eik meta lodash   ","version":"Next","tagName":"h2"},{"title":"Updating a published package​","type":1,"pageTitle":"Publishing to the npm namespace","url":"/docs/dependencies/npm#updating-a-published-package","content":" New versions of the module need to be published to the Eik server, either manually or with automation like Renovate or Dependabot. Whether you choose to automate or have a manual process, these are the steps to update a module.  Update the dependency in package.json and installUpdate the version number in eik.jsonRun the build scriptPublish to the Eik server  Keeping with our lodash example, say it's been updated to 4.18.0. First you would update the dependency in package.json.  { &quot;dependencies&quot;: { - &quot;lodash&quot;: &quot;4.17.21&quot; + &quot;lodash&quot;: &quot;4.18.0&quot; }, }   Then similarly update the version number in eik.json.  { -\t&quot;version&quot;: &quot;4.17.21&quot;, +\t&quot;version&quot;: &quot;4.18.0&quot;, }   Run npm install to download the updated module, then rerun the build with npm run build.  npm install npm run build   Commit the updated files.  Now you can publish the updated module to Eik.  eik login --key YOUR_EIK_KEY eik publish   ","version":"Next","tagName":"h2"},{"title":"Next steps​","type":1,"pageTitle":"Publishing to the npm namespace","url":"/docs/dependencies/npm#next-steps","content":" Now that you have seen how to publish different versions of a shared dependency to Eik it's time to set up an alias. ","version":"Next","tagName":"h2"},{"title":"Publish to Eik on Travis","type":0,"sectionRef":"#","url":"/docs/guides/travis","content":"","keywords":"","version":"Next"},{"title":"Setup secrets in Travis​","type":1,"pageTitle":"Publish to Eik on Travis","url":"/docs/guides/travis#setup-secrets-in-travis","content":" Two secrets will need to be available in order to publish to your Eik server and commit to your git repository. Travis provides a settings page where you can set secret environment variables and we recommend that you use this to do so.  The Eik server key will need to be obtained from your Eik server provider, a Github personal access token can be created by visiting this page.    ","version":"Next","tagName":"h2"},{"title":"Set up versioning and publishing in .travis.yml​","type":1,"pageTitle":"Publish to Eik on Travis","url":"/docs/guides/travis#set-up-versioning-and-publishing-in-travisyml","content":" The following gives an example of how to run version and publish commands from .travis.yml. The login command uses the EIK_SERVER_KEY that was setup in the previous step.  language: node_js node_js: - 20 before_script: - npm install --global @eik/cli@^2 script: - eik login --key $EIK_SERVER_KEY - eik version - eik publish   If you have a build step that you need to run before publish, you could just insert that into the script section as shown.  script: - &lt;build command here&gt; - eik login --key $EIK_SERVER_KEY - eik version - eik publish   ","version":"Next","tagName":"h2"},{"title":"Create a commit script​","type":1,"pageTitle":"Publish to Eik on Travis","url":"/docs/guides/travis#create-a-commit-script","content":" The most challenging part of publishing from CI is committing back to your git repository. The following is an example of a script that commits changes to eik.json and pushes that commit back to github. It uses the GH_TOKEN script defined in the first step.  commit.sh  #!/usr/bin/env bash # Set the repo name from the github url # For git@github.schibsted.io:finn/min-finn.git, the repo name would be min-finn REPO=&quot;&lt;repo name&gt;&quot; # Travis doesn't make it easy to get the current branch so... this... BRANCH=$(if [ &quot;$TRAVIS_PULL_REQUEST&quot; == &quot;false&quot; ]; then echo $TRAVIS_BRANCH; else echo $TRAVIS_PULL_REQUEST_BRANCH; fi) # Set the user email and name for the commit, set these to whatever you prefer git config --global user.email &quot;travis@travis-ci.org&quot; git config --global user.name &quot;Travis CI&quot; # Travis checks out a commit hash rather than a branch so we need to add the branch, fetch it and check it out git remote set-branches --add origin $BRANCH git fetch origin git branch $BRANCH origin/$BRANCH git checkout $BRANCH # Push the changes to the remote git push origin $BRANCH   ","version":"Next","tagName":"h2"},{"title":"Run the commit script from .travis.yml​","type":1,"pageTitle":"Publish to Eik on Travis","url":"/docs/guides/travis#run-the-commit-script-from-travisyml","content":" script: - eik login -k $EIK_SERVER_KEY - eik version - eik publish - ./commit.sh   Once setup, when you push changes to Github, if any of the files to be published have changed, you should automatically get a new published version of your assets on your Eik server and your eik.json file will have been updated with the new semver version number. ","version":"Next","tagName":"h2"},{"title":"Using Eik with Rollup","type":0,"sectionRef":"#","url":"/docs/guides/rollup","content":"","keywords":"","version":"Next"},{"title":"Getting started​","type":1,"pageTitle":"Using Eik with Rollup","url":"/docs/guides/rollup#getting-started","content":" Install @eik/rollup-plugin, and rollup if you haven't already.  npm install --save-dev rollup @eik/rollup-plugin   ","version":"Next","tagName":"h2"},{"title":"Configure your build​","type":1,"pageTitle":"Using Eik with Rollup","url":"/docs/guides/rollup#configure-your-build","content":" Create rollup.config.js or extend your existing config to add the Eik plugin.  import eik from &quot;@eik/rollup-plugin&quot;; export default { input: &quot;source/main.js&quot;, plugins: [eik()], output: { file: &quot;build.js&quot;, format: &quot;esm&quot;, }, };   ","version":"Next","tagName":"h2"},{"title":"Run your build​","type":1,"pageTitle":"Using Eik with Rollup","url":"/docs/guides/rollup#run-your-build","content":" Add this script to package.json if you haven't already.  { &quot;scripts&quot;: { &quot;build&quot;: &quot;rollup --config&quot; } }   Now you can run a production build using the Eik plugin by running this command.  npm run build   ","version":"Next","tagName":"h2"},{"title":"Advanced usage​","type":1,"pageTitle":"Using Eik with Rollup","url":"/docs/guides/rollup#advanced-usage","content":" See the plugin documentation for advanced options on loading import maps.  ","version":"Next","tagName":"h2"},{"title":"Vite compatibility​","type":1,"pageTitle":"Using Eik with Rollup","url":"/docs/guides/rollup#vite-compatibility","content":" You can use this Rollup plugin in your Vite build should you need to.  import eik from &quot;@eik/rollup-plugin&quot;; import { defineConfig } from &quot;vite&quot;; export default defineConfig({ plugins: [ { ...eik(), enforce: &quot;pre&quot;, // only apply plugin for client code, while building apply: (_config, { command, isSsrBuild }) =&gt; command === &quot;build&quot; &amp;&amp; !isSsrBuild, }, ], };  ","version":"Next","tagName":"h2"},{"title":"Publish to Eik on GitHub Actions","type":0,"sectionRef":"#","url":"/docs/guides/github-actions","content":"","keywords":"","version":"Next"},{"title":"Prerequisites​","type":1,"pageTitle":"Publish to Eik on GitHub Actions","url":"/docs/guides/github-actions#prerequisites","content":" Your repo needs to have access to an Eik login key. Store this as a Secret you can use in GitHub Actions.  In this guide we'll be using EIK_TOKEN as the secret name.  ","version":"Next","tagName":"h2"},{"title":"Using Semantic Release​","type":1,"pageTitle":"Publish to Eik on GitHub Actions","url":"/docs/guides/github-actions#using-semantic-release","content":" There is an Eik plugin for Semantic Release you can use to automatically update the version number in eik.json based on conventional commits.  To use it, update your release.config.js to add the plugin, and commit eik.json back to Git.  export default { plugins: [ &quot;@eik/semantic-release&quot;, [&quot;@semantic-release/git&quot;, { assets: [&quot;eik.json&quot;] }], ], };   ","version":"Next","tagName":"h2"},{"title":"Semantic release workflow​","type":1,"pageTitle":"Publish to Eik on GitHub Actions","url":"/docs/guides/github-actions#semantic-release-workflow","content":" With the Eik plugin configured, update your release workflow to pass on the EIK_TOKEN secret to semantic-release.  - name: Release env: GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} NPM_TOKEN: ${{ secrets.NPM_TOKEN }} EIK_TOKEN: ${{ secrets.EIK_TOKEN }} run: npx semantic-release   ","version":"Next","tagName":"h3"},{"title":"Using the Eik CLI​","type":1,"pageTitle":"Publish to Eik on GitHub Actions","url":"/docs/guides/github-actions#using-the-eik-cli","content":" You can automate publishing to Eik using the Eik CLI.  This example requires you manually update the version number in eik.json.  name: Publish to Eik on: push: branches: - main paths: - eik.json jobs: publish: runs-on: [ubuntu-latest] steps: - uses: actions/checkout@v4 - uses: actions/setup-node@v4 with: node-version: 20 # you can also add @eik/cli to your devDependencies - run: npm install --global @eik/cli@^3 - name: Publish to Eik run: | eik login --key ${{secrets.EIK_TOKEN}} eik publish   ","version":"Next","tagName":"h2"},{"title":"Automatically increment the patch version number​","type":1,"pageTitle":"Publish to Eik on GitHub Actions","url":"/docs/guides/github-actions#automatically-increment-the-patch-version-number","content":" If you don't really care about the version number you can use the eik version command to increment the version number on CI. The version will only be updated if the CLI detects there are changes to the files.  Remember to commit the updated eik.json back to your repository.  name: Publish to Eik on: push: branches: - main jobs: publish: runs-on: [ubuntu-latest] steps: - uses: actions/checkout@v4 - uses: actions/setup-node@v4 with: node-version: 20 # you can also add @eik/cli to your devDependencies - run: npm install --global @eik/cli@^3 - name: Publish to Eik run: | eik login --key ${{secrets.EIK_TOKEN}} eik version || true eik publish - name: Commit updated eik.json if version changed # git diff --quiet will exit with code 0 if there are no changes. # if there _are_ changes (a new version), the right-hand side of || will run run: | git config --global user.name &quot;github-actions[bot]&quot; git config --global user.email &quot;41898282+github-actions[bot]@users.noreply.github.com&quot; git diff --quiet || (git commit --all --message &quot;chore: update version number in eik.json [skip ci]&quot; &amp;&amp; git push origin HEAD) shell: bash  ","version":"Next","tagName":"h3"},{"title":"Using Eik with Webpack","type":0,"sectionRef":"#","url":"/docs/guides/webpack","content":"","keywords":"","version":"Next"},{"title":"Getting started​","type":1,"pageTitle":"Using Eik with Webpack","url":"/docs/guides/webpack#getting-started","content":" Install @eik/webpack-plugin, and webpack if you haven't already.  npm install --save-dev webpack webpack-cli @eik/webpack-plugin   ","version":"Next","tagName":"h2"},{"title":"Configure your build​","type":1,"pageTitle":"Using Eik with Webpack","url":"/docs/guides/webpack#configure-your-build","content":" Create webpack.config.js or extend your existing config to add the Eik plugin.  export default { entry: &quot;./src/input.js&quot;, output: { environment: { // Eik requires ESM output module: true, }, filename: &quot;bundle.js&quot;, path: &quot;./public/&quot;, }, experiments: { // Eik requires ESM output outputModule: true, }, module: { rules: [ { test: /\\.js$/, use: { loader: &quot;@eik/webpack-plugin&quot;, }, }, ], }, };   ","version":"Next","tagName":"h2"},{"title":"Run your build​","type":1,"pageTitle":"Using Eik with Webpack","url":"/docs/guides/webpack#run-your-build","content":" Add this script to package.json if you haven't already.  { &quot;scripts&quot;: { &quot;build&quot;: &quot;webpack&quot;, &quot;dev&quot;: &quot;webpack --watch&quot; } }   Now you can run a production build using the Eik plugin by running this command.  npm run build   ","version":"Next","tagName":"h2"},{"title":"Advanced usage​","type":1,"pageTitle":"Using Eik with Webpack","url":"/docs/guides/webpack#advanced-usage","content":" See the plugin documentation for advanced options on loading import maps. ","version":"Next","tagName":"h2"},{"title":"Using Eik with PostCSS","type":0,"sectionRef":"#","url":"/docs/guides/postcss","content":"","keywords":"","version":"Next"},{"title":"Getting started​","type":1,"pageTitle":"Using Eik with PostCSS","url":"/docs/guides/postcss#getting-started","content":" Install @eik/postcss-plugin, and postcss if you haven't already.  npm install --save-dev postcss postcss-cli @eik/postcss-plugin   ","version":"Next","tagName":"h2"},{"title":"Configure your build​","type":1,"pageTitle":"Using Eik with PostCSS","url":"/docs/guides/postcss#configure-your-build","content":" Create postcss.config.js or extend your existing config to add the Eik plugin.  import eik from &quot;@eik/postcss-plugin&quot;; /** @type {import('postcss-load-config').Config} */ export default { map: true, plugins: [eik()], };   You can also use the JavaScript API for postcss.  import fs from &quot;node:fs&quot;; import path from &quot;node:path&quot;; import eik from &quot;@eik/postcss-plugin&quot;; import postcss from &quot;postcss&quot;; const from = &quot;css/input.css&quot;; const to = &quot;public/output.css&quot;; const css = fs.readFileSync(path.join(process.cwd(), from), &quot;utf-8&quot;); postcss() .use(eik()) .process(css, { from, }) .then((result) =&gt; { fs.writeFileSync(path.join(process.cwd(), to), result.css, &quot;utf-8&quot;); });   ","version":"Next","tagName":"h2"},{"title":"Run your build​","type":1,"pageTitle":"Using Eik with PostCSS","url":"/docs/guides/postcss#run-your-build","content":" Assuming you use postcss-cli and postcss.config.js, add these scripts to package.json if you haven't already.  { &quot;scripts&quot;: { &quot;build&quot;: &quot;postcss src/input.css --output ./public/output.css --config ./postcss.config.js&quot;, &quot;dev&quot;: &quot;npm run build -- --watch&quot; } }   ","version":"Next","tagName":"h2"},{"title":"Advanced usage​","type":1,"pageTitle":"Using Eik with PostCSS","url":"/docs/guides/postcss#advanced-usage","content":" See the plugin documentation for advanced configuration of import maps.See postcss-cli for available options.See postcss for integrations with other build tools. ","version":"Next","tagName":"h2"},{"title":"Get started using Eik","type":0,"sectionRef":"#","url":"/docs/introduction/workflow","content":"","keywords":"","version":"Next"},{"title":"Preparing to use Eik​","type":1,"pageTitle":"Get started using Eik","url":"/docs/introduction/workflow#preparing-to-use-eik","content":" tip If your organisation doesn't have a running Eik server yet, hop on over to the server documentation.  To use Eik, first we need an eik.json configuration file. Use the Eik CLI to generate one in your current directory. It should be in the same directory as package.json.  npx @eik/cli init   If you prefer, you can also configure Eik in package.json. We'll assume you use eik.json for the rest of this guide, but whenever these docs mention eik.json it applies to &quot;eik&quot; in package.json as well.  Open eik.json and fill in these details:  nameversionserverfiles (paths relative to eik.json)import-maps  { &quot;name&quot;: &quot;my-app&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;server&quot;: &quot;https://eik.store.com&quot;, &quot;files&quot;: &quot;./public&quot;, &quot;import-map&quot;: [&quot;https://eik.store.com/map/store/v1&quot;] }   You'll probably find your organisation's import maps in a shared repository. See Managing dependencies if you don't have any import maps yet.  ","version":"Next","tagName":"h2"},{"title":"Build-time import mapping​","type":1,"pageTitle":"Get started using Eik","url":"/docs/introduction/workflow#build-time-import-mapping","content":" tip If all your target browsers support import maps natively (or you use a polyfill) you can skip this section and use import mapping in the browser instead.  As support for import maps in the browser matures you may want to do build-time import mapping and ship ES modules with absolute import strings to the browser.    To apply import maps at build-time you need a build tool. Eik includes plugins for common build tools, and they all work much the same way.  Look for eik.json to find the URL of the Eik server.Fetch the configured import maps from the Eik server.Attach to the build process in some way.When a bare import is discovered that matches an import map, replace that import with the Eik URL.  See the Guides section for several examples. When the build is done you should see references to your Eik server in the built JavaScript.  ","version":"Next","tagName":"h2"},{"title":"Publish your application to Eik​","type":1,"pageTitle":"Get started using Eik","url":"/docs/introduction/workflow#publish-your-application-to-eik","content":" The next step is publishing the built application to Eik.  Strictly speaking, this is optional. You can host your client-side assets elsewhere and only use Eik for shared dependencies and import maps. Still, there are some benefits to hosting your application code on Eik.  There is only one asset server to manage.You can reuse the same HTTP/2 connection for dependencies and application code.Your application code is versioned and immutable, and can be cached &quot;forever&quot;.  You can upload using the Eik CLI, or using Semantic Release (which versions automatically). This example uses the CLI.  First, update the version in eik.json.  eik version   By default eik version increments the patch number in semantic versioning. You can increment the minor and major versions with an additional argument.  eik version minor   Commit the updated version to your repo. Ensure you have built the assets you want to publish.  Once you're ready, login in to the Eik server and publish. These steps can be done on your continuous integration servers if you prefer.  eik login --key YOUR_EIK_KEY eik publish   note The examples above assumes you installed the Eik CLI using npm install --global @eik/cli.  You might want to automate publishing to Eik on a continuous integration service. This guide explains how to publish to Eik using GitHub Actions.  ","version":"Next","tagName":"h2"},{"title":"Linking to your assets from HTML​","type":1,"pageTitle":"Get started using Eik","url":"/docs/introduction/workflow#linking-to-your-assets-from-html","content":" Once your assets are published to Eik, URLs to the assets can be derived from the fields in eik.json.  Here's our example eik.json again.  { &quot;server&quot;: &quot;https://eik.store.com&quot;, &quot;name&quot;: &quot;my-app&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;files&quot;: &quot;./public&quot;, &quot;import-map&quot;: [&quot;https://eik.store.com/map/store/v1&quot;] }   Say our ./public directory has a file app.js. After publishing we can reference that file like so.  &lt;!-- server + &quot;/pkg/ + name + &quot;/&quot; + version + &quot;/&quot; + filename.ext --&gt; &lt;!-- assuming ./public/app.js exists when publishing --&gt; &lt;script src=&quot;https://eik.store.com/pkg/my-app/1.0.0/app.js&quot;&gt;&lt;/script&gt;   ","version":"Next","tagName":"h2"},{"title":"@eik/node-client​","type":1,"pageTitle":"Get started using Eik","url":"/docs/introduction/workflow#eiknode-client","content":" You likely want to use a different URL when developing, and only point to Eik in production. Since this is a common operation, Eik includes a module for Node apps that helps generate these links.  import Eik from &quot;@eik/node-client&quot;; const development = process.env.NODE_ENV === &quot;development&quot;; const client = new Eik({ base: &quot;/public&quot;, // this base path will only be used if development is true development, }); await client.load(); // load the config from eik.json if (development) { // set up your app to serve local versions from disk on /public, // for instance with serve-static } // value will point to /public/app.js if development is true, // and https://eik.store.com/pkg/my-app/1.0.0/app.js otherwise const { value, integrity } = client.file(&quot;/app.js&quot;); const scriptTag = `&lt;script type=&quot;module&quot; src=&quot;${value}&quot; integrity=&quot;${integrity}&quot;&gt;&lt;/script&gt;`;   ","version":"Next","tagName":"h3"},{"title":"Next steps​","type":1,"pageTitle":"Get started using Eik","url":"/docs/introduction/workflow#next-steps","content":" Congratulations! You've taken steps to make your application more performant by sharing ES modules in the browser.  At this point you may go forth and code, but if you'd like you can learn about  publishing shared dependencies to Eikgathering shared dependencies in import maps ","version":"Next","tagName":"h2"},{"title":"Introduction to Eik","type":0,"sectionRef":"#","url":"/docs/introduction/","content":"","keywords":"","version":"Next"},{"title":"The problem Eik solves​","type":1,"pageTitle":"Introduction to Eik","url":"/docs/introduction/#the-problem-eik-solves","content":" A common architecture for web applications is to have separate applications serving different pathnames. These typically have client-side JavaScript, and may often share the same dependencies.    Take the illustrated user journey for store.com above.  store.com is one applicationstore.com/shop is anotherstore.com/checkout is a third  A user will normally arrive at the front page, move to browsing the shop and then finish at the checkout.  Let's say the applications on store.com are using Lit for templating in the browser. Without Eik, all three applications ship with their own version of Lit. The browser needs to download, parse and execute Lit three times.  ","version":"Next","tagName":"h2"},{"title":"Sharing ES modules with Eik​","type":1,"pageTitle":"Introduction to Eik","url":"/docs/introduction/#sharing-es-modules-with-eik","content":" Sticking with our store.com example, if all three applications import Lit from Eik instead of shipping their own, the user's browser can cache the HTTP request between page views.  import Lit from &quot;https://eik.store.com/npm/lit/1.0.0/index.js&quot;;   tip HTTP imports aren't the prettiest, but we'll be improving things with import mapping soon! In your source code you'll still be using the bare imports you are familiar with when using bundlers.  ","version":"Next","tagName":"h2"},{"title":"Taking advantage of the ES module cache​","type":1,"pageTitle":"Introduction to Eik","url":"/docs/introduction/#taking-advantage-of-the-es-module-cache","content":" Eik is designed to take advantage of the ES module cache as well. From Lin Clark's ES modules: A cartoon deep-dive:  Any module that is in both of these graphs is going to share a module instance. This is because the loader caches module instances. For each module in a particular global scope, there will only be one module instance. This means less work for the engine. For example, it means that the module file will only be fetched once even if multiple modules depend on it. [...] The module map caches the module by canonical URL so that there is only one module record for each module. That ensures each module is only executed once.  The ES module cache is mostly relevant for micro-frontend architectures (where multiple apps can share the same global scope), but know that even if multiple modules import a shared dependency over HTTP the browser will only download and execute it once.  ","version":"Next","tagName":"h3"},{"title":"Further improving performance with aliases​","type":1,"pageTitle":"Introduction to Eik","url":"/docs/introduction/#further-improving-performance-with-aliases","content":" Now that our three apps on store.com all use Eik to import Lit we run into a different problem: version management.    Going back to the user journey for store.com, imagine that:  store.com loads lit@1.2.0store.com/shop loads lit@1.1.1store.com/checkout loads lit@1.1.2  At this point we're back to square one. Each page visit means downloading, parsing and executing Lit.  We can tell from the semantic version numbers that they could all use lit@1.2.0 and be fine. This is where aliases come in.  Instead of importing specific versions, Eik encourages the use of aliases to share the same major semantic version between applications.  import Lit from &quot;https://eik.store.com/npm/lit/v1/index.js&quot;;     When all three applications point to the same alias the browser's HTTP cache ensures we don't download Lit more than once in the user journey.  tip Another bonus with aliases is that new versions of a dependency can be published to Eik, and with an alias update it gets applied to all apps that depend on it – no redeploys needed ✨  ","version":"Next","tagName":"h2"},{"title":"Import mapping​","type":1,"pageTitle":"Introduction to Eik","url":"/docs/introduction/#import-mapping","content":" You may be used to writing bare import strings like this.  import Lit from &quot;lit&quot;;   Imports like the above depend on Node's module resolution algorithm. You then typically use a bundler to do that module resolution at build-time, and end up with one or more JavaScript files that include all the imported dependencies.  To use ES modules in the browser you can't rely on Node's resolution algoritm. Specification compliant ES module imports must be either relative or absolute.  A relative ESM import statement must start with either /, ./ or ../:  import * as mymod from &quot;/my_module.js&quot;; import * as mymod from &quot;./my_module.js&quot;; import * as mymod from &quot;../my_module.js&quot;;   An absolute import must be a fully formed URL:  import * as mylib from &quot;https://eik-server.com/pkg/mylib/v3/main.js&quot;;   ","version":"Next","tagName":"h2"},{"title":"Using bare imports in source code with maps​","type":1,"pageTitle":"Introduction to Eik","url":"/docs/introduction/#using-bare-imports-in-source-code-with-maps","content":" Import maps is a browser feature that lets developers keep the ergonomics of bare imports, even when using ES modules in the browser. Import maps are a special script type where the bare import is a key, and the mapped import string (either relative or absolute) is the value.  &lt;script type=&quot;importmap&quot;&gt; { &quot;imports&quot;: { &quot;lit-html&quot;: &quot;https://eik.store.com/npm/lit/v1/index.js&quot; } } &lt;/script&gt;   Sharing the import maps themselves on Eik​  You can publish import maps to Eik in a similar way to dependencies and application code. Maps are versioned and immutable, and can be aliased in the same way other assets can. Browser import mapping explains how you can include these shared import maps in your HTTP responses.  Import maps on Eik look similar to those in the browser, only without the &lt;script&gt; tag. The bare import as a key on the left and its absolute value on the right:  { &quot;imports&quot;: { &quot;lit&quot;: &quot;https://eik.store.com/npm/lit/v1/index.js&quot; } }   Build-time import mapping​  Depending on your requirements for browser support, using import maps in the browser may not be feasible. There is a polyfill you can include to add support at the cost of some additional JavaScript.  Eik includes tools to do this import mapping at build-time. Check out the Guides section for several examples.  These build tools look up the configured import maps shared on the Eik server and replace bare imports with absolute imports pointing to the Eik server.  Given the following source code and import map, a correctly configured build tool will replace the bare import in source with the Eik URL in the built JavaScript bundle.  // The source import Lit from &quot;lit&quot;;   { &quot;imports&quot;: { &quot;lit&quot;: &quot;https://eik.store.com/npm/lit/v1/index.js&quot; } }   // The result import * as lit from &quot;https://eik.store.com/npm/lit/v1/index.js&quot;;   ","version":"Next","tagName":"h3"},{"title":"Next steps​","type":1,"pageTitle":"Introduction to Eik","url":"/docs/introduction/#next-steps","content":" Now that you've learned about how Eik works to improve performance in the browser it's time to learn how to work with Eik as an application developer. ","version":"Next","tagName":"h2"},{"title":"@eik/cli reference","type":0,"sectionRef":"#","url":"/docs/reference/at-eik-cli","content":"","keywords":"","version":"Next"},{"title":"Install and run commands​","type":1,"pageTitle":"@eik/cli reference","url":"/docs/reference/at-eik-cli#install-and-run-commands","content":" To install the Eik CLI globally:  npm install --global @eik/cli   This makes the command eik available in your shell.  eik --help   To uninstall a globally installed Eik CLI:  npm uninstall --global @eik/cli   ","version":"Next","tagName":"h2"},{"title":"Eik command autocomplete in your shell​","type":1,"pageTitle":"@eik/cli reference","url":"/docs/reference/at-eik-cli#eik-command-autocomplete-in-your-shell","content":" If you would like to be able to use tab key autocompletion for Eik commands, you can concatentate the following script to your .zshrc or .bashrc file.  ###-begin-eik-completions-### _eik_yargs_completions() { local reply local si=$IFS IFS=$' ' reply=($(COMP_CWORD=&quot;$((CURRENT-1))&quot; COMP_LINE=&quot;$BUFFER&quot; COMP_POINT=&quot;$CURSOR&quot; eik --get-yargs-completions &quot;${words[@]}&quot;)) IFS=$si _describe 'values' reply } compdef _eik_yargs_completions eik ###-end-eik-completions-###   Once done, you should be able to hit tab while typing Eik commands and get autocomplete suggestions.  ","version":"Next","tagName":"h3"},{"title":"As a devDependency​","type":1,"pageTitle":"@eik/cli reference","url":"/docs/reference/at-eik-cli#as-a-devdependency","content":" You can also add the Eik CLI as a devDependency.  npm install --save-dev @eik/cli   Now you can use npx eik to run commands with the version of the Eik CLI in your project.  npx eik --help   You can also add scripts to package.json and run them that way.  { &quot;scripts&quot;: { &quot;eik:publish&quot;: &quot;eik publish&quot; } }   npm run eik:publish   ","version":"Next","tagName":"h3"},{"title":"Using npx​","type":1,"pageTitle":"@eik/cli reference","url":"/docs/reference/at-eik-cli#using-npx","content":" You can run the Eik CLI from anywhere using npx.  npx @eik/cli --help   ","version":"Next","tagName":"h3"},{"title":"Available commands​","type":1,"pageTitle":"@eik/cli reference","url":"/docs/reference/at-eik-cli#available-commands","content":" Run eik with --help to see a description of all available commands and their aliases in your shell.  eik --help   You can also get help for each individual command the same way.  eik init --help   ","version":"Next","tagName":"h2"},{"title":"alias​","type":1,"pageTitle":"@eik/cli reference","url":"/docs/reference/at-eik-cli#alias","content":" Create or update an alias for a package, npm package, image or import map as identified by its name, version and type.  A package with the given name and version must already exist on the Eik server. The alias should be the semver major part of the package version. Eg. for a package of version 5.4.3, you should use 5 as the alias. The alias type (npm, map, package, image) is detected from eik.json in the current working directory.  eik alias &lt;name&gt; &lt;version&gt; &lt;alias&gt;   Replaces package-alias, map-alias and npm-alias from version 3.0.0 onward.  ","version":"Next","tagName":"h3"},{"title":"init​","type":1,"pageTitle":"@eik/cli reference","url":"/docs/reference/at-eik-cli#init","content":" Creates a new default eik.json and saves it to the current working directory.  eik init   ","version":"Next","tagName":"h3"},{"title":"integrity​","type":1,"pageTitle":"@eik/cli reference","url":"/docs/reference/at-eik-cli#integrity","content":" Retrieve file integrity information for package name and version defined in eik.json, then populate integrity.json file with this information for use in subresource integrity.  eik integrity [name] [version]   ","version":"Next","tagName":"h3"},{"title":"login​","type":1,"pageTitle":"@eik/cli reference","url":"/docs/reference/at-eik-cli#login","content":" Write operations require you to be logged in to the Eik server. To log in, run the login command.  eik login   The login command will ask for a server URL and a server key.  Server keys are configured on the server and, once entered, the client will authenticate with the server and receive back a JSON web token which it will save in an .eikrc file in the users home directory for use in subsequent commands.    Log in without the command prompt​  It is possible to bypass login prompts by providing the server URL and key via command line flags.  eik login --server https://eik.store.com --key YOUR_EIK_KEY   Log in with multiple Eik servers​  It is possible to be authenticated against several Eik servers at once by calling the eik login command multiple times and providing different server URLs and keys each time.  eik login --server https://eik1.store.com --key YOUR_EIK_KEY eik login --server https://eik2.store.com --key YOUR_EIK_KEY   Once logged in​  So long as the client is logged in to a single server, all subsequent commands will know which server to use and provide credentials automatically.  eik publish   N.B. If the client is authenticated with more than one server, it may be necessary to tell the client which server to use when using commands since the client will not decide which authenticated server to give precedence to. The --server (or -s for short) flag can be used to do this.  eik publish --server https://eik.store.com   ","version":"Next","tagName":"h3"},{"title":"map-alias​","type":1,"pageTitle":"@eik/cli reference","url":"/docs/reference/at-eik-cli#map-alias","content":" This command is deprecated, use eik alias  See alias  ","version":"Next","tagName":"h3"},{"title":"meta​","type":1,"pageTitle":"@eik/cli reference","url":"/docs/reference/at-eik-cli#meta","content":" Retrieve meta information by package, map or npm name.  If a given name exists in several types (package and map for example), results will be returned and displayed from all matching types.  eik meta &lt;name&gt;   ","version":"Next","tagName":"h3"},{"title":"npm-alias​","type":1,"pageTitle":"@eik/cli reference","url":"/docs/reference/at-eik-cli#npm-alias","content":" This command is deprecated, use eik alias  See alias  ","version":"Next","tagName":"h3"},{"title":"package-alias​","type":1,"pageTitle":"@eik/cli reference","url":"/docs/reference/at-eik-cli#package-alias","content":" This command is deprecated, use eik alias  See alias  ","version":"Next","tagName":"h3"},{"title":"ping​","type":1,"pageTitle":"@eik/cli reference","url":"/docs/reference/at-eik-cli#ping","content":" Ping an Eik server to check that it is responding.  eik ping [server]   ","version":"Next","tagName":"h3"},{"title":"publish​","type":1,"pageTitle":"@eik/cli reference","url":"/docs/reference/at-eik-cli#publish","content":" Publish a package to an Eik server. Reads configuration from eik.json or package.json.  eik publish   ","version":"Next","tagName":"h3"},{"title":"@eik/service reference","type":0,"sectionRef":"#","url":"/docs/reference/at-eik-service","content":"","keywords":"","version":"Next"},{"title":"Constructor​","type":1,"pageTitle":"@eik/service reference","url":"/docs/reference/at-eik-service#constructor","content":" Create a new Eik service instance.  import Service from &quot;@eik/service&quot;; const service = new Service(options);   ","version":"Next","tagName":"h2"},{"title":"options (optional)​","type":1,"pageTitle":"@eik/service reference","url":"/docs/reference/at-eik-service#options-optional","content":" option\tdefault\ttype\tdetailssink\tnull\tobject\tThe storage sink you would like to use. logger\tnull\tobject\tAn instance of the pino logger. customSink\tnull\tobject\tDeprecated. Use sink. aliasCacheControl\t&quot;public, max-age=1200&quot;\tstring\tCache-Control header to respond with when getting an alias. notFoundCacheControl\t&quot;public, max-age=5&quot;\tstring\tCache-Control header to respond with when returning 404 Not Found. pkgMaxFileSize\t10_000_000\tnumber\tThe limit in bytes before PUT /pkg/:name/:version starts returning 413 Content Too Large. mapMaxFileSize\t1_000_000\tnumber\tThe limit in bytes before PUT /map/:name/:version starts returning 413 Content Too Large.  ","version":"Next","tagName":"h3"},{"title":"API​","type":1,"pageTitle":"@eik/service reference","url":"/docs/reference/at-eik-service#api","content":" An Eik service instance has the following API:  ","version":"Next","tagName":"h2"},{"title":".api()​","type":1,"pageTitle":"@eik/service reference","url":"/docs/reference/at-eik-service#api-1","content":" The Eik service as a Fastify plugin. The returned function must be passed on to the Fastify .register() method:  import fastify from &quot;fastify&quot;; import Service from &quot;@eik/service&quot;; // Set up the Eik service as a plugin const service = new Service({ sink }); // Set up Fastify const app = fastify({ ignoreTrailingSlash: true, }); // Register the Eik service in Fastify app.register(service.api());   This will make the Eik HTTP API available.  Due to how the HTTP API deals with wildcards on pathnames to resolve files, it is recommended that the ignoreTrailingSlash option on the Fastify constructor that the plugin is registered to is set to true. If this is not done, file resolving might not work as expected.  ","version":"Next","tagName":"h3"},{"title":".health()​","type":1,"pageTitle":"@eik/service reference","url":"/docs/reference/at-eik-service#health","content":" Runs a health check on the Eik service. Throws if any of the health checks fails.  The health check mainly determines if the service is able to run all methods on the configured storage sink.  We recommend executing the health check before the service begins accepting HTTP traffic.  const run = async () =&gt; { await service.health(); await app.listen({ port: service.config.get(&quot;http.port&quot;), host: service.config.get(&quot;http.address&quot;), }); }; run();   ","version":"Next","tagName":"h3"},{"title":"Properties​","type":1,"pageTitle":"@eik/service reference","url":"/docs/reference/at-eik-service#properties","content":" An Eik service instance has the following properties:  ","version":"Next","tagName":"h2"},{"title":".metrics​","type":1,"pageTitle":"@eik/service reference","url":"/docs/reference/at-eik-service#metrics","content":" Property that exposes a metric stream. Please see the metrics section for usage information.  ","version":"Next","tagName":"h3"},{"title":".config​","type":1,"pageTitle":"@eik/service reference","url":"/docs/reference/at-eik-service#config","content":" Property that exposes configuration via convict.  import Service from &quot;@eik/service&quot;; const service = new Service(); service.logger.info(`Server is running in ${service.config.get(&quot;env&quot;)} mode`);   ","version":"Next","tagName":"h3"},{"title":".logger​","type":1,"pageTitle":"@eik/service reference","url":"/docs/reference/at-eik-service#logger","content":" Property that exposes the pino logger instance.  import Service from &quot;@eik/service&quot;; const service = new Service(); service.logger.info(`Server is running in ${service.config.get(&quot;env&quot;)} mode`);   ","version":"Next","tagName":"h3"},{"title":".sink​","type":1,"pageTitle":"@eik/service reference","url":"/docs/reference/at-eik-service#sink","content":" Property that exposes the currently used storage sink. ","version":"Next","tagName":"h3"},{"title":"version​","type":1,"pageTitle":"@eik/cli reference","url":"/docs/reference/at-eik-cli#version","content":" Compares local files with files on server and increments the &quot;version&quot; field in eik.json if necessary.  eik version [level]   ","version":"Next","tagName":"h3"},{"title":"Programatic usage​","type":1,"pageTitle":"@eik/cli reference","url":"/docs/reference/at-eik-cli#programatic-usage","content":" If you need to script commands from the Eik CLI, consider importing @eik/cli in JavaScript.  The programatic API is mostly the same as the CLI, although the CLI has some extra named commands that use the same programatic API behind the scenes.  import cli from &quot;@eik/cli&quot;;   Your editor should be able to show code suggestions and inline documentation for the API.  ","version":"Next","tagName":"h2"},{"title":"alias​","type":1,"pageTitle":"@eik/cli reference","url":"/docs/reference/at-eik-cli#alias-1","content":" Create or update an alias for a package on the Eik server.  const result = await cli.alias({ server, name, version, alias, token, type, });   ","version":"Next","tagName":"h3"},{"title":"integrity​","type":1,"pageTitle":"@eik/cli reference","url":"/docs/reference/at-eik-cli#integrity-1","content":" Get integrity information of a published asset.  const result = await cli.integrity({ server, name, version, });   ","version":"Next","tagName":"h3"},{"title":"login​","type":1,"pageTitle":"@eik/cli reference","url":"/docs/reference/at-eik-cli#login-1","content":" Log in using a key to get the token needed by other commands.  const result = await cli.integrity({ server, key, });   ","version":"Next","tagName":"h3"},{"title":"map​","type":1,"pageTitle":"@eik/cli reference","url":"/docs/reference/at-eik-cli#map","content":" Publish a map to the Eik server.  const result = await cli.map({ server, name, version, file, token, });   ","version":"Next","tagName":"h3"},{"title":"meta​","type":1,"pageTitle":"@eik/cli reference","url":"/docs/reference/at-eik-cli#meta-1","content":" Get metadata about a published asset.  const result = await cli.meta({ server, name, version, });   ","version":"Next","tagName":"h3"},{"title":"ping​","type":1,"pageTitle":"@eik/cli reference","url":"/docs/reference/at-eik-cli#ping-1","content":" Ping the Eik server.  const result = await cli.ping({ server, });   ","version":"Next","tagName":"h3"},{"title":"publish​","type":1,"pageTitle":"@eik/cli reference","url":"/docs/reference/at-eik-cli#publish-1","content":" Publish a package to the Eik server.  const result = await cli.publish({ server, name, version, file, token, type, });   ","version":"Next","tagName":"h3"},{"title":"version​","type":1,"pageTitle":"@eik/cli reference","url":"/docs/reference/at-eik-cli#version-1","content":" Similar to npm version, but updates eik.json.  const result = await cli.version({ server, name, version, files, type, });  ","version":"Next","tagName":"h3"},{"title":"@eik/sink reference","type":0,"sectionRef":"#","url":"/docs/reference/at-eik-sink","content":"","keywords":"","version":"Next"},{"title":"Constructor​","type":1,"pageTitle":"@eik/sink reference","url":"/docs/reference/at-eik-sink#constructor","content":" A sink must be a class which extends the Eik sink interface.  import Sink from &quot;@eik/sink&quot;; class SinkCustom extends Sink { constructor() { super(); } write() {} read() {} delete() {} exist() {} get metrics() {} }   ","version":"Next","tagName":"h2"},{"title":"API​","type":1,"pageTitle":"@eik/sink reference","url":"/docs/reference/at-eik-sink#api","content":" A sink must implement the following API:  ","version":"Next","tagName":"h2"},{"title":"write(filePath, contentType)​","type":1,"pageTitle":"@eik/sink reference","url":"/docs/reference/at-eik-sink#writefilepath-contenttype","content":" argument\tdefault\ttype\trequired\tdetailsfilePath\tnull\tstring\ttrue\tPathname of the file relative to root in the file structure in Eik contentType\tnull\tstring\ttrue\tContent type of the file  This method is called when a file is to be written to storage. The method must return a Promise and resolve with a WritableStream when the storage is ready to be written too. The server will pipe the byte stream of the file to this stream. Upon any errors, the promise should reject with an Error object  import { Writable } from 'node:stream'; import Sink from '@eik/sink'; export class SinkCustom extends Sink { constructor() { super(); } write() { return new Promise(resolve, reject) { const to = new Writable(); resolve(to); } } }   ","version":"Next","tagName":"h3"},{"title":"read(filePath)​","type":1,"pageTitle":"@eik/sink reference","url":"/docs/reference/at-eik-sink#readfilepath","content":" argument\tdefault\ttype\trequired\tdetailsfilePath\tnull\tstring\ttrue\tPathname of the file relative to root in the file structure in Eik  This method is called when a file is to be read from storage. The method must return a Promise and resolve with a ReadableStream when the storage is ready to be read from. Upon any errors, the promise should reject with an Error object  import { Readable } from 'node:stream'; import Sink from '@eik/sink'; export class SinkCustom extends Sink { constructor() { super(); } read() { return new Promise(resolve, reject) { const to = new Readable(); resolve(to); } } }   ","version":"Next","tagName":"h3"},{"title":"delete(filePath)​","type":1,"pageTitle":"@eik/sink reference","url":"/docs/reference/at-eik-sink#deletefilepath","content":" argument\tdefault\ttype\trequired\tdetailsfilePath\tnull\tstring\ttrue\tPathname of the file relative to root in the file structure in Eik  This method is called when a file is to be deleted from storage. The method must return a Promise and resolve with no value when the file is deleted from storage. If any errors occur, the promise should reject with an Error object  ","version":"Next","tagName":"h3"},{"title":"exist(filePath)​","type":1,"pageTitle":"@eik/sink reference","url":"/docs/reference/at-eik-sink#existfilepath","content":" argument\tdefault\ttype\trequired\tdetailsfilePath\tnull\tstring\ttrue\tPathname of the file relative to root in the file structure in Eik  This method is called to check if a file exists in storage. The method must return a Promise and resolve with no value if the file exists in storage. If the file does not exist the promise should reject with no error object. Upon any errors, the promise should reject with an Error object.  ","version":"Next","tagName":"h3"},{"title":"Properties​","type":1,"pageTitle":"@eik/sink reference","url":"/docs/reference/at-eik-sink#properties","content":" A sink must implement the following properties:  ","version":"Next","tagName":"h2"},{"title":".metrics​","type":1,"pageTitle":"@eik/sink reference","url":"/docs/reference/at-eik-sink#metrics","content":" A getter for a metric stream. The metric stream can be used to emit metrics from the sink into the overall metric stream in the server.  Example:  import Metrics from @metrics/client'; import Sink from @eik/sink'; export class SinkCustom extends Sink { constructor() { super(); this._metrics = new Metrics(); this._counter = this._metrics.counter({ name: 'eik_custom_sink', description: 'Counter measuring access to the custom sink', }); } write(filePath, contentType) { return new Promise(resolve, reject) { this._counter.inc(); } } }   ","version":"Next","tagName":"h3"},{"title":"Validation​","type":1,"pageTitle":"@eik/sink reference","url":"/docs/reference/at-eik-sink#validation","content":" We recommend you validate the arguments for all methods. The Eik sink interface contain static methods to do so which can be used when implementing a sink:  import Sink from @eik/sink'; export class SinkCustom extends Sink { constructor() { super(); } write(filePath, contentType) { return new Promise(resolve, reject) { try { super.constructor.validateFilePath(filePath); super.constructor.validateContentType(contentType); } catch (error) { reject(error); return; } } } }   ","version":"Next","tagName":"h2"},{"title":"Security​","type":1,"pageTitle":"@eik/sink reference","url":"/docs/reference/at-eik-sink#security","content":" A sink should take care of protecting against Path Traversal. It should not be possible to access files outside the root of the file structure in Eik by passing in a hostile pathname through the REST API of Eik. Each filePath argument on each method should be checked for such.  Please see OWASPs guide on preventing Path Traversal. ","version":"Next","tagName":"h2"},{"title":"eik.json reference","type":0,"sectionRef":"#","url":"/docs/reference/eik-json","content":"","keywords":"","version":"Next"},{"title":"Using eik.json​","type":1,"pageTitle":"eik.json reference","url":"/docs/reference/eik-json#using-eikjson","content":" The most common way to configure an Eik setup is to create and populate an eik.json file in a project's root, next to package.json.  { &quot;$schema&quot;: &quot;https://raw.githubusercontent.com/eik-lib/common/main/lib/schemas/eikjson.schema.json&quot;, &quot;name&quot;: &quot;my-app&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;server&quot;: &quot;https://eik.store.com&quot;, &quot;files&quot;: &quot;./public&quot;, &quot;import-map&quot;: [&quot;https://eik.store.com/map/store/v1&quot;] }   ","version":"Next","tagName":"h2"},{"title":"Using package.json​","type":1,"pageTitle":"eik.json reference","url":"/docs/reference/eik-json#using-packagejson","content":" It is also possible to configure Eik via package.json.  { &quot;eik&quot;: { &quot;$schema&quot;: &quot;https://raw.githubusercontent.com/eik-lib/common/main/lib/schemas/eikjson.schema.json&quot;, &quot;name&quot;: &quot;my-app&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;server&quot;: &quot;https://eik.store.com&quot;, &quot;files&quot;: &quot;./public&quot;, &quot;import-map&quot;: [&quot;https://eik.store.com/map/store/v1&quot;] } }   It is also possible to have Eik use the package.json name and version fields by omitting them from the configuration.  { &quot;name&quot;: &quot;my-app&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;eik&quot;: { &quot;$schema&quot;: &quot;https://raw.githubusercontent.com/eik-lib/common/main/lib/schemas/eikjson.schema.json&quot;, &quot;server&quot;: &quot;https://eik.store.com&quot;, &quot;files&quot;: &quot;./public&quot;, &quot;import-map&quot;: [&quot;https://eik.store.com/map/store/v1&quot;] } }   ","version":"Next","tagName":"h2"},{"title":"Creating eik.json​","type":1,"pageTitle":"eik.json reference","url":"/docs/reference/eik-json#creating-eikjson","content":" The Eik CLI includes a scaffolding tool that can be used to generate an eik.json file in the current directory.  eik init   ","version":"Next","tagName":"h2"},{"title":"JSON schema​","type":1,"pageTitle":"eik.json reference","url":"/docs/reference/eik-json#json-schema","content":" The schema is available on GitHub. Add this to your configuration to get code suggestions and inline documentation in some editors.  { &quot;$schema&quot;: &quot;https://raw.githubusercontent.com/eik-lib/common/main/lib/schemas/eikjson.schema.json&quot; }   ","version":"Next","tagName":"h2"},{"title":"name​","type":1,"pageTitle":"eik.json reference","url":"/docs/reference/eik-json#name","content":" required  Defines the value that will be used on the Eik server to configure the name for the project. This should be unique to an organisation.  See storage sink for more information.  ","version":"Next","tagName":"h3"},{"title":"version​","type":1,"pageTitle":"eik.json reference","url":"/docs/reference/eik-json#version","content":" required  Defines the current Eik package version using semantic versioning.  This must be unique to a given package name within an organisation. Attempting to republish the same version a second time will fail.  You can manually update this value or use the eik version command to automate the process.  { &quot;version&quot;: &quot;1.0.0&quot; }   ","version":"Next","tagName":"h3"},{"title":"type​","type":1,"pageTitle":"eik.json reference","url":"/docs/reference/eik-json#type","content":" optional (default package)  Defines the package type. Must be one of package, npm or map. Setting this value changes the URL publish namespace between /pkg (default), /npm and /map.  ","version":"Next","tagName":"h3"},{"title":"server​","type":1,"pageTitle":"eik.json reference","url":"/docs/reference/eik-json#server","content":" required  Defines the URL of the Eik server that the project will publish to.  See the server docs for how to setup and configure an Eik server.  { &quot;server&quot;: &quot;https://eik.store.com&quot; }   ","version":"Next","tagName":"h3"},{"title":"files​","type":1,"pageTitle":"eik.json reference","url":"/docs/reference/eik-json#files","content":" required  Defines files to publish.  This can be a string defining a folder or a single entrypoint, or it can be an object that maps publish paths to local file system file locations.  In this example, all files in the ./public folder would be uploaded to the Eik server.  { &quot;files&quot;: &quot;./public&quot; }   You can use glob syntax to decide which files to include.  { &quot;files&quot;: &quot;./public/**/*.js&quot; }   You can configure &quot;files&quot; as an object to map different files or folders on disk to public paths.  Keys define publish locations on the Eik server and values define the local file entrypoint locations. This somewhat resembles [package entrypoints](https://nodejs.org/dist/latest/docs/api/packages.html#package-entry-points in Node.  { &quot;files&quot;: { // `./path/to/esm.js` is uploaded and renamed to `/script.js` &quot;script.js&quot;: &quot;./path/to/esm.js&quot;, // `/absolute/path/to/esm.js` is uploaded and renamed to `/script.js` &quot;script.js&quot;: &quot;/absolute/path/to/esm.js&quot;, // everything in `./path/to/folder` is uploaded to `/folder` &quot;folder&quot;: &quot;./path/to/folder&quot;, // everything in `./path/to/folder` is uploaded to `/folder` (but no folder recursion) &quot;folder&quot;: &quot;./path/to/folder/*&quot;, // everything in `./path/to/folder` is uploaded to `/folder/scripts` &quot;folder/scripts&quot;: &quot;path/to/folder/**/*&quot;, }, }   ","version":"Next","tagName":"h3"},{"title":"import-map​","type":1,"pageTitle":"eik.json reference","url":"/docs/reference/eik-json#import-map","content":" optional  Configure import maps that will be used during a build. This can be specified as a single string or as an array of strings if you want to use more than one import map in the build.  { &quot;import-map&quot;: &quot;https://eik.store.com/map/store/v1&quot; }   or  { &quot;import-map&quot;: [ &quot;https://eik.store.com/map/store/v1&quot;, &quot;https://eik.store.com/map/store-2/v1&quot; ] }   ","version":"Next","tagName":"h3"},{"title":"out​","type":1,"pageTitle":"eik.json reference","url":"/docs/reference/eik-json#out","content":" optionaldefault: ./.eik  Configure the Eik build directory. Eik will store resource integrity information in this directory, and may use it for other features in the future.  { &quot;out&quot;: &quot;./eik&quot; }  ","version":"Next","tagName":"h3"},{"title":"@eik/node-client","type":0,"sectionRef":"#","url":"/docs/reference/at-eik-node-client","content":"","keywords":"","version":"Next"},{"title":"Setting up an Eik server","type":0,"sectionRef":"#","url":"/docs/server/","content":"","keywords":"","version":"Next"},{"title":"Testing an Eik server from the command line​","type":1,"pageTitle":"Setting up an Eik server","url":"/docs/server/#testing-an-eik-server-from-the-command-line","content":" The fastest way to test a running instance of the Eik server is by using npx.  npx @eik/service   This will install the latest Eik server and start it at http://localhost:4001.  warning By default all uploads are stored in a temporary directory that will be lost when your operating system cleans it up. To configure a persistent storage, set the SINK_PATH environment variable to a suitable location on disk.  ","version":"Next","tagName":"h2"},{"title":"Production setup​","type":1,"pageTitle":"Setting up an Eik server","url":"/docs/server/#production-setup","content":" @eik/service also includes a Fastify plugin, so you can configure and extend the Eik service to fit your needs.  In this example we set up an Eik server using the local file system for storage. Use or implement a different sink if you need other another storage solution.  Create a new project and install the required dependencies  mkdir eik-server cd eik-server npm init -y npm install fastify @eik/service @eik/sink-file-system   Create index.js and add the following.  import path from &quot;node:path&quot;; import fastify from &quot;fastify&quot;; import Service from &quot;@eik/service&quot;; import Sink from &quot;@eik/sink-file-system&quot;; const sink = new Sink({ sinkFsRootPath: path.join(process.cwd(), &quot;.eik&quot;, &quot;storage&quot;), }); const service = new Service({ sink }); const app = fastify({ ignoreTrailingSlash: true, modifyCoreObjects: false, trustProxy: true, }); app.register(service.api()); const run = async () =&gt; { await service.health(); await app.listen({ port: service.config.get(&quot;http.port&quot;), host: service.config.get(&quot;http.address&quot;), }); }; run();   ","version":"Next","tagName":"h2"},{"title":"Configuring for production​","type":1,"pageTitle":"Setting up an Eik server","url":"/docs/server/#configuring-for-production","content":" @eik/service reads YAML configuration from config/ based on NODE_ENV.  Add config/production.yaml to change secrets and other commonly used settings.  mkdir config touch config/development.yaml touch config/production.yaml   See the @eik/service config to see what values you can configure. Here's a typical config/production.yaml.  organization: # replace with your organisation name name: store hostnames: - localhost # replace with your Eik server's domain - eik.store.com jwt: # replace with the absolute path to a file holding your # jwt secret as plaintext (uses convict-format-secrets) secret: /var/run/secrets/auth_jwt_secret basicAuth: # replace with the absolute path to a file holding your # basic auth key as plaintext (uses convict-format-secrets) key: /var/run/secrets/basic_auth_key http: port: 8080 address: &quot;0.0.0.0&quot; log: level: info   ","version":"Next","tagName":"h3"},{"title":"Run your Eik server​","type":1,"pageTitle":"Setting up an Eik server","url":"/docs/server/#run-your-eik-server","content":" To run your Eik server with Node in production:  NODE_ENV=production node index.js   To run your Eik server with Node in development:  NODE_ENV=development node index.js  ","version":"Next","tagName":"h3"},{"title":"Install​","type":1,"pageTitle":"@eik/node-client","url":"/docs/reference/at-eik-node-client#install","content":" npm install @eik/node-client   ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"@eik/node-client","url":"/docs/reference/at-eik-node-client#usage","content":" The most common use case for this module is linking to a file. When developing you typically want to use a local version of the file, then link to the published version on Eik when running in production.  For that you use the file() method, which returns an object { value, integrity } where value is the link to the file.  When running in production the link will point to the file on Eik. When development is true the pathname is prefixed with the base option instead of pointing to Eik, so your app can use a local version.  // Serve a local version of a file from `./public` // in development and from Eik in production import path from &quot;node:path&quot;; import Eik from &quot;@eik/node-client&quot;; import fastifyStatic from &quot;@fastify/static&quot;; import fastify from &quot;fastify&quot;; const app = fastify(); // Serve the contents of the ./public folder on the path /public app.register(fastifyStatic, { root: path.join(process.cwd(), &quot;public&quot;), prefix: &quot;/public/&quot;, }); const eik = new Eik({ development: process.env.NODE_ENV === &quot;development&quot;, // base is only used when `development` is `true` base: &quot;/public&quot;, }); // load information from `eik.json` and the Eik server await eik.load(); // when development is true script.value will be /public/script.js // when development is false script.value will be // https://{server}/pkg/{name}/{version}/script.js // where {server}, {name} and {version} are read from eik.json const script = eik.file(&quot;/script.js&quot;); app.get(&quot;/&quot;, (req, reply) =&gt; { reply.type(&quot;text/html; charset=utf-8&quot;); reply.send(` &lt;html&gt; &lt;body&gt; &lt;script src=&quot;${script.value}&quot; ${script.integrity ? `integrity=&quot;${script.integrity}&quot;` : } type=&quot;module&quot; &gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt;`); }); app.listen({ port: 3000, }); console.log(&quot;Listening on http://localhost:3000&quot;);   ","version":"Next","tagName":"h2"},{"title":"Include a <script type=\"importmap\">​","type":1,"pageTitle":"@eik/node-client","url":"/docs/reference/at-eik-node-client#include-a-script-typeimportmap","content":" This module can also download the import maps defined in Eik config so you can include them in your HTML responses.  const client = new Eik({ loadMaps: true, }); await client.load(); const maps = client.maps(); const combined = maps.reduce((map, acc) =&gt; ({ ...acc, ...map }), {}); const html = ` &lt;script type=&quot;importmap&quot;&gt; ${JSON.stringify(combined, null, 2)} &lt;/script&gt; `;   ","version":"Next","tagName":"h3"},{"title":"Constructor​","type":1,"pageTitle":"@eik/node-client","url":"/docs/reference/at-eik-node-client#constructor","content":" Use the default export to create a new instance.  You must call load before using the instance so it can read from eik.json and your Eik server.  import Eik from &quot;@eik/node-client&quot;; const eik = new Eik(); await eik.load();   ","version":"Next","tagName":"h2"},{"title":"options​","type":1,"pageTitle":"@eik/node-client","url":"/docs/reference/at-eik-node-client#options","content":" option\tdefault\ttype\trequired\tdetailsbase\tnull\tstring\tfalse\tBase root to be used for returned asset files. development\tfalse\tboolean\tfalse\tSet the module in development mode or not. loadMaps\tfalse\tboolean\tfalse\tSpecifies whether import maps defined in the config should be loaded from the Eik server or not. path\tprocess.cwd()\tstring\tfalse\tPath to directory containing an eik.json file or package.json with eik config.  ","version":"Next","tagName":"h3"},{"title":"API​","type":1,"pageTitle":"@eik/node-client","url":"/docs/reference/at-eik-node-client#api","content":" ","version":"Next","tagName":"h2"},{"title":"async .load()​","type":1,"pageTitle":"@eik/node-client","url":"/docs/reference/at-eik-node-client#async-load","content":" Reads the Eik config from disk into the object instance.  If loadMaps was set to true the import maps defined in the config will be fetched from the Eik server.  ","version":"Next","tagName":"h3"},{"title":".file(pathname)​","type":1,"pageTitle":"@eik/node-client","url":"/docs/reference/at-eik-node-client#filepathname","content":" Get a link to a file that will differ based on environment (development vs production).  When running in production the returned link will point to the file on Eik.  // in production const eik = new Eik({ development: false, }); await eik.load(); const file = eik.file(&quot;/path/to/script.js&quot;); // { // value: https://eik.store.com/pkg/my-app/1.0.0/path/to/script.js // integrity: sha512-zHQjnD-etc. // } // where the server URL, app name and version are read from eik.json // { // &quot;name&quot;: &quot;my-app&quot;, // &quot;version&quot;: &quot;1.0.0&quot;, // &quot;server&quot;: &quot;https://eik.store.com&quot;, // }   When development is true the pathname is prefixed with the base option instead of pointing to Eik.  // in development const eik = new Eik({ development: true, base: &quot;/public&quot;, }); await eik.load(); const file = eik.file(&quot;/path/to/script.js&quot;); // { // value: /public/path/to/script.js // integrity: undefined // }   arguments​  option\tdefault\ttype\tdetailspathname\tnull\tstring\tPathname relative to the base on Eik (ex: /path/to/script.js for a prod URL https://eik.store.com/pkg/my-app/1.0.0/path/to/script.js)  returns​  Returns an object with value and integrity:  { integrity: 'sha512-zHQjnDpMW7IKVyTpT9cOPT1+xhUSOcbgXj6qHCPSPu1CbQfgwDEsIniXU54zDIN71zqmxLSp3hfIljpt69ok0w==', value: 'https://eik.store.com/pkg/my-app/1.0.0/path/to/script.js' }   integrity is undefined if development is true:  { integrity: undefined, value: '/public/path/to/script.js' }   ","version":"Next","tagName":"h3"},{"title":".maps()​","type":1,"pageTitle":"@eik/node-client","url":"/docs/reference/at-eik-node-client#maps","content":" When loadMaps is true and you call load, the client fetches the configured import maps from the Eik server.  This method returns the import maps that were fetched during load.  const client = new Eik({ loadMaps: true, }); await client.load(); const maps = client.maps(); const combined = maps.reduce((map, acc) =&gt; ({ ...acc, ...map }), {}); const html = ` &lt;script type=&quot;importmap&quot;&gt; ${JSON.stringify(combined, null, 2)} &lt;/script&gt; `;   returns​  A list of Eik import maps.  [ { &quot;imports&quot;: { &quot;date-fns&quot;: &quot;https://eik.store.com/npm/date-fns/v3/index.js&quot;, &quot;lodash&quot;: &quot;https://eik.store.com/npm/lodash/v4/index.js&quot; } }, { &quot;imports&quot;: { &quot;lit&quot;: &quot;https://eik.store.com/npm/lit/v3/index.js&quot; } } ]   ","version":"Next","tagName":"h3"},{"title":".base()​","type":1,"pageTitle":"@eik/node-client","url":"/docs/reference/at-eik-node-client#base","content":" Constructs a URL to the base of a package of assets. The returned value will differ depending on if development mode is set to true or not.  When in non development mode, the returned value will be built up by the values found in the loaded Eik config and provide a URL to where the files can be expected to be on the Eik server.  const client = new Eik({ development: false, base: &quot;http://localhost:8080/assets&quot;, }); await client.load(); client.base(); // https://cdn.eik.dev/pkg/mymodue/2.4.1   When in development mode, the returned value will be equal to whats set on the base argument on the constructor.  const client = new Eik({ development: true, base: &quot;http://localhost:8080/assets&quot;, }); await client.load(); client.base(); // http://localhost:8080/assets  ","version":"Next","tagName":"h3"},{"title":"Storage sinks","type":0,"sectionRef":"#","url":"/docs/server/storage","content":"","keywords":"","version":"Next"},{"title":"Built in sinks​","type":1,"pageTitle":"Storage sinks","url":"/docs/server/storage#built-in-sinks","content":" @eik/service ships with two built in sinks, intended for local development and testing:  File systemMemory  ","version":"Next","tagName":"h2"},{"title":"File system​","type":1,"pageTitle":"Storage sinks","url":"/docs/server/storage#file-system","content":" This is the default sink when you start the Eik server. The file system sink will write files to and from the local file system.  warning By default all files are stored in the default OS temp folder. Do note that files stored in the default OS temp folder will, on most OSes, be deleted without warning by the OS at some point. To configure a different folder, use the SINK_PATH environment variable.  You can also import @eik/sink-file-system and configure the sink that way.  import Service from &quot;@eik/service&quot;; import Sink from &quot;@eik/sink-file-system&quot;; const sink = new Sink({ sinkFsRootPath: path.join(process.cwd(), &quot;.eik&quot;, &quot;storage&quot;), }); const service = new Service({ sink });   ","version":"Next","tagName":"h3"},{"title":"In memory​","type":1,"pageTitle":"Storage sinks","url":"/docs/server/storage#in-memory","content":" The in memory sink will write files to and from memory. Files written to this sink will disappear when the Eik server is restarted. This sink is handy for spinning up an Eik server to run tests.  To use it, set the SINK_TYPE environment variable to mem.  You can also import @eik/sink-memory and configure the sink that way.  import Service from &quot;@eik/service&quot;; import Sink from &quot;@eik/sink-memory&quot;; const sink = new Sink(); const service = new Service({ sink });   ","version":"Next","tagName":"h3"},{"title":"Custom sinks​","type":1,"pageTitle":"Storage sinks","url":"/docs/server/storage#custom-sinks","content":" A custom sink is normally pulled in as a dependent module and passed on to the sink property on the constructor of the @eik/service in a production setup.  A custom sink takes its own set of properties, such as authentication keys, so please see the documentation for each sink for what's required.  ","version":"Next","tagName":"h2"},{"title":"Available custom sinks​","type":1,"pageTitle":"Storage sinks","url":"/docs/server/storage#available-custom-sinks","content":" These custom sinks are available:  Google Cloud Storage  Feel free to open a pull request to list a custom sink you've made, and use the eik-sink topic if you publish on GitHub.  import fastify from &quot;fastify&quot;; import Service from &quot;@eik/service&quot;; import Sink from &quot;@eik/sink-gcs&quot;; const sink = new Sink({ credentials: { client_email: &quot;an@email.address&quot;, private_key: &quot;[ ...snip... ]&quot;, projectId: &quot;myProject&quot;, }, }); const service = new Service({ sink }); const app = fastify({ ignoreTrailingSlash: true, }); app.register(service.api());   ","version":"Next","tagName":"h3"},{"title":"Making a custom sink​","type":1,"pageTitle":"Storage sinks","url":"/docs/server/storage#making-a-custom-sink","content":" A custom sink must extend the Eik sink interface and implement all the methods in the public API and its public properties.  ","version":"Next","tagName":"h3"},{"title":"Internal storage structure​","type":1,"pageTitle":"Storage sinks","url":"/docs/server/storage#internal-storage-structure","content":" The Eik server stores files in the following structure inside the storage sink.  :root └── :org ├── map │ └── :name │ ├── :version.import-map.json │ ├── :major.alias.json │ └── versions.json ├── pkg │ └── :name │ ├── :version │ │ ├── * │ ├── :version.package.json │ ├── :major.alias.json │ └── versions.json └── npm └── :name ├── :version │ ├── * ├── :version.package.json ├── :major.alias.json └── versions.json   Parameters:  :root is the root folder for everything.:org is the name of an organisation.:name is the name of a package.:version is the full semver version of a package.:major is the major semver version of a full semver version of a package.  ","version":"Next","tagName":"h2"},{"title":"Packages​","type":1,"pageTitle":"Storage sinks","url":"/docs/server/storage#packages","content":" Packages are stored under /:root/:org/pkg/:name/:version/ and the structure of a package is arbitrary and untouched during upload by the service.  The file structure of a package is stored in a package file at /:root/:org/pkg/:name/:version.package.json.  ","version":"Next","tagName":"h3"},{"title":"npm​","type":1,"pageTitle":"Storage sinks","url":"/docs/server/storage#npm","content":" NPM packages are packages from the NPM registry that are then published to Eik as a &quot;copy&quot;. Packages from the NPM registry are published under this namespace to avoid name collision with other packages.  NPM packages are stored under /:root/:org/npm/:name/:version/ and the structure of a package is arbitrary and is not changed during upload by the service.  The file structure of an NPM package is stored in a package meta file at /:root/:org/pkg/:name/:version.package.json.  ","version":"Next","tagName":"h3"},{"title":"Import maps​","type":1,"pageTitle":"Storage sinks","url":"/docs/server/storage#import-maps","content":" Import maps are stored under /:root/:org/map/:name/:version.import-map.json. The filename of import maps is strict and conforms to the version number it's given with a .json extension.  The filename of import maps prior to uploading to the service can be anything. The service will convert the file name according to the parameters given when uploading it.  ","version":"Next","tagName":"h3"},{"title":"Aliases​","type":1,"pageTitle":"Storage sinks","url":"/docs/server/storage#aliases","content":" Packages, NPM packages and import map versions can be aliased. An alias is a semver major version of a full semver version and is a way to map a major version to a given full semver version of a package or import map.  This alias mapping is stored alongside the version of a package or import map version:  Package alias path: /:root/:org/pkg/:name/:major.alias.jsonNPM package alias path: /:root/:org/npm/:name/:major.alias.jsonImport map alias path: /:root/:org/map/:name/:major.alias.json ","version":"Next","tagName":"h3"},{"title":"HTTP API","type":0,"sectionRef":"#","url":"/docs/server/http-api","content":"","keywords":"","version":"Next"},{"title":"Authentication​","type":1,"pageTitle":"HTTP API","url":"/docs/server/http-api#authentication","content":" Authentication is needed to execute multiple API calls in the REST API.  ","version":"Next","tagName":"h2"},{"title":"Endpoint Summary Table​","type":1,"pageTitle":"HTTP API","url":"/docs/server/http-api#endpoint-summary-table","content":" Name\tVerb\tEndpoint\tForm FieldsLogin\tPOST\t/auth/login\tkey  ","version":"Next","tagName":"h3"},{"title":"Login​","type":1,"pageTitle":"HTTP API","url":"/docs/server/http-api#login","content":" Method: POST  Logs a user in to the service.  https://:assetServerUrl:port/auth/login   Form parameters:  key an authentication key  Status codes:  200 if user is authorized401 if user is not authorized  Success response: A jwt token  { &quot;token&quot;: &quot;...&quot; }   Example:  curl -X POST -i -F key=rfm940c3 http://localhost:4001/auth/login   ","version":"Next","tagName":"h3"},{"title":"Packages​","type":1,"pageTitle":"HTTP API","url":"/docs/server/http-api#packages","content":" A packages is a set of files (javascript, css etc) that is intended to be referenced from an HTML document and loaded by a browser.  Packages are versioned and consist of one or more files. A package of a specific version is immutable.  ","version":"Next","tagName":"h2"},{"title":"Endpoint Summary Table​","type":1,"pageTitle":"HTTP API","url":"/docs/server/http-api#endpoint-summary-table-1","content":" Name\tVerb\tEndpoint\tForm FieldsPublic Package URL\tGET\t/pkg/:name/:version/:extras Upload a Package\tPUT\t/pkg/:name/:version\tpackage  ","version":"Next","tagName":"h3"},{"title":"Public Package URL​","type":1,"pageTitle":"HTTP API","url":"/docs/server/http-api#public-package-url","content":" Method: GET  Retrieves files from a package on the service.  https://:assetServerUrl:port/pkg/:name/:version/:extras   URL parameters:  :name is the name of the package. Validator: Comply with npm package names.:version is the version of the package. Validator: Comply with semver validation regex.:extras whildcard pathname to any file in the package  Status codes:  200 if file is successfully retrieved404 if file is not found  Example:  curl -X GET http://localhost:4001/pkg/fuzz/8.4.1/main/index.js   ","version":"Next","tagName":"h3"},{"title":"Upload a package​","type":1,"pageTitle":"HTTP API","url":"/docs/server/http-api#upload-a-package","content":" Method: PUT  Puts a new package at the service.  https://:assetServerUrl:port/pkg/:name/:version   URL parameters:  :name is the name of the package. Validator: Comply with npm package names.:version is the version of the package. Validator: Comply with semver validation regex.  Form parameters:  package a tar or tar.gz containing the files of the package  HTTP headers:  Authorization a jwt authorization bearer with the token retrieved from a successful authentication  Status codes:  303 if package is successfully uploaded. location is root of module400 if validation in URL parameters or form fields fails401 if user is not authorized409 if package already exists or version in a major range is not newer than previous version in a major range413 if package is too large415 if file format of the uploaded file is unsupported422 if a entry in the uploaded file could not be parsed or errored502 if package could not be written to the sink  Example:  curl -X PUT -i -F package=@archive.tgz -H &quot;Authorization: Bearer {:token}&quot; http://localhost:4001/pkg/fuzz/8.4.1   ","version":"Next","tagName":"h3"},{"title":"Latest Package versions​","type":1,"pageTitle":"HTTP API","url":"/docs/server/http-api#latest-package-versions","content":" Method: GET  Retrieves an overview of the latest major versions of a package.  https://:assetServerUrl:port/pkg/:name   URL parameters:  :name is the name of the package. Validator: Comply with npm package names.  Status codes:  200 if file is successfully retrieved404 if file is not found  Example:  curl -X GET http://localhost:4001/pkg/fuzz   ","version":"Next","tagName":"h3"},{"title":"Package version overview​","type":1,"pageTitle":"HTTP API","url":"/docs/server/http-api#package-version-overview","content":" Method: GET  Retrieves an overview of the files of a package version.  https://:assetServerUrl:port/pkg/:name/:version   URL parameters:  :name is the name of the package. Validator: Comply with npm package names.:version is the version of the package. Validator: Comply with semver validation regex.  Status codes:  200 if file is successfully retrieved404 if file is not found  Example:  curl -X GET http://localhost:4001/pkg/fuzz   ","version":"Next","tagName":"h3"},{"title":"NPM Packages​","type":1,"pageTitle":"HTTP API","url":"/docs/server/http-api#npm-packages","content":" An NPM package is a local replica of a package found in the NPM registry intended to be referenced from an HTML document and loaded by a browser. In most cases, with some exceptions, an NPM Package will be a library or utillity that other Packages depend upon.  NPM Packages are versioned and consist of one or more files. An NPM package of a specific version is immutable.  ","version":"Next","tagName":"h2"},{"title":"Endpoint Summary Table​","type":1,"pageTitle":"HTTP API","url":"/docs/server/http-api#endpoint-summary-table-2","content":" Name\tVerb\tEndpoint\tForm FieldsPublic NPM Package URL\tGET\t/npm/:name/:version/:extras Upload an NPM Package\tPUT\t/npm/:name/:version\tpackage  ","version":"Next","tagName":"h3"},{"title":"Public NPM Package URL​","type":1,"pageTitle":"HTTP API","url":"/docs/server/http-api#public-npm-package-url","content":" Method: GET  Retrieves files from an NPM package on the service.  https://:assetServerUrl:port/npm/:name/:version/:extras   URL parameters:  :name is the name of the NPM package. Validator: Comply with npm package names.:version is the version of the NPM package. Validator: Comply with semver validation regex.:extras wildcard pathname to any file in the NPM package  Status codes:  200 if file is successfully retrieved404 if file is not found  Example:  curl -X GET http://localhost:4001/npm/fuzz/8.4.1/main/index.js   ","version":"Next","tagName":"h3"},{"title":"Upload a NPM Package​","type":1,"pageTitle":"HTTP API","url":"/docs/server/http-api#upload-a-npm-package","content":" Method: PUT  Puts a new NPM package on the service.  https://:assetServerUrl:port/npm/:name/:version   URL parameters:  :name is the name of the NPM package. Validator: Comply with npm package names.:version is the version of the NPM package. Validator: Comply with semver validation regex.  Form parameters:  package a tar or tar.gz containing the files of the NPM package  HTTP headers:  Authorization a JWT authorization bearer with the token retrieved from a successful authentication  Status codes:  303 if NPM package is successfully uploaded. location is root of module400 if validation in URL parameters or form fields fails401 if user is not authorized409 if NPM package already exist or version in a major range is not newer than previous version in a major range413 if package is too large415 if file format of the uploaded file is unsupported422 if a entry in the uploaded file could not be parsed or errored502 if NPM package could not be written to the sink  Example:  curl -X PUT -i -F package=@archive.tgz -H &quot;Authorization: Bearer {:token}&quot; http://localhost:4001/npm/fuzz/8.4.1   ","version":"Next","tagName":"h3"},{"title":"Latest NPM Package versions​","type":1,"pageTitle":"HTTP API","url":"/docs/server/http-api#latest-npm-package-versions","content":" Method: GET  Retrieves an overview of the latest major versions of an NPM package.  https://:assetServerUrl:port/npm/:name   URL parameters:  :name is the name of the NPM package. Validator: Comply with npm package names.  Status codes:  200 if file is successfully retrieved404 if file is not found  Example:  curl -X GET http://localhost:4001/npm/fuzz   ","version":"Next","tagName":"h3"},{"title":"NPM Package version overview​","type":1,"pageTitle":"HTTP API","url":"/docs/server/http-api#npm-package-version-overview","content":" Method: GET  Retrieves an overview of the files of an NPM package version.  https://:assetServerUrl:port/npm/:name/:version   URL parameters:  :name is the name of the NPM package. Validator: Comply with npm package names.:version is the version of the NPM package. Validator: Comply with semver validation regex.  Status codes:  200 if file is successfully retrieved404 if file is not found  Example:  curl -X GET http://localhost:4001/npm/fuzz   ","version":"Next","tagName":"h3"},{"title":"Import Maps​","type":1,"pageTitle":"HTTP API","url":"/docs/server/http-api#import-maps","content":" An import map holds a mapping or a set of mappings between ECMA Script Module (ESM) bare imports and an absolute URL. Import maps are versioned and are immutable.  ","version":"Next","tagName":"h2"},{"title":"Endpoint Summary Table​","type":1,"pageTitle":"HTTP API","url":"/docs/server/http-api#endpoint-summary-table-3","content":" Name\tVerb\tEndpoint\tForm FieldsPublic Import Map URL\tGET\t/map/:name/:version Upload an Import Map\tPUT\t/map/:name/:version\tmap  ","version":"Next","tagName":"h3"},{"title":"Public Import Map URL​","type":1,"pageTitle":"HTTP API","url":"/docs/server/http-api#public-import-map-url","content":" Method: GET  Retrieves an import map from the service.  https://:assetServerUrl:port/map/:name/:version   URL parameters:  :name is the name of the import map. Validator: Comply with npm package names.:version is the version of the import map. Validator: Comply with semver validation regex.  Status codes:  200 if import map is successfully retrieved404 if import map is not found  Example:  curl -X GET http://localhost:4001/map/buzz/8.4.1   ","version":"Next","tagName":"h3"},{"title":"Upload an Import Map​","type":1,"pageTitle":"HTTP API","url":"/docs/server/http-api#upload-an-import-map","content":" Method: PUT  Puts a new import map at the service.  https://:assetServerUrl:port/map/:name/:version   URL parameters:  :name is the name of the import map. Validator: Comply with npm package names.:version is the version of the import map. Validator: Comply with semver validation regex.  Form parameters:  map a json file (the import map)  HTTP headers:  Authorization a jwt authorization bearer with the token retrieved from a successful authentication  Status codes:  303 if import map is successfully uploaded. location is Public Import Map URL400 if validation in URL parameters or form fields fails401 if user is not authorized409 if import map already exist415 if file format of the uploaded import map is unsupported502 if import map could not be written to the sink  Example:  curl -X PUT -i -F map=@import-map.json -H &quot;Authorization: Bearer {:token}&quot; http://localhost:4001/map/buzz/8.4.1   ","version":"Next","tagName":"h3"},{"title":"Latest Import Map versions​","type":1,"pageTitle":"HTTP API","url":"/docs/server/http-api#latest-import-map-versions","content":" Method: GET  Retrieves an overview of the latest versions of a Import Map.  https://:assetServerUrl:port/map/:name   URL parameters:  :name is the name of the import map. Validator: Comply with npm package names.  Status codes:  200 if file is successfully retrieved404 if file is not found  Example:  curl -X GET http://localhost:4001/map/buzz   ","version":"Next","tagName":"h3"},{"title":"Aliases​","type":1,"pageTitle":"HTTP API","url":"/docs/server/http-api#aliases","content":" An alias is a shorthand between a major version of a package / import map and the set exact version of the package / import map.  ","version":"Next","tagName":"h2"},{"title":"Endpoint Summary Table​","type":1,"pageTitle":"HTTP API","url":"/docs/server/http-api#endpoint-summary-table-4","content":" Name\tVerb\tEndpoint\tForm FieldsPublic Alias URL\tGET\t/:type/:name/v:alias/:extras Create Alias\tPUT\t/:type/:name/v:alias\tversion Update Alias\tPOST\t/:type/:name/v:alias\tversion Delete Alias\tDELETE\t/:type/:name/v:alias\t  ","version":"Next","tagName":"h3"},{"title":"Public Alias URL​","type":1,"pageTitle":"HTTP API","url":"/docs/server/http-api#public-alias-url","content":" Method: GET  Retrieves files from a package or an import map at the service.  https://:assetServerUrl:port/:type/:name/v:alias/:extras   URL parameters:  :type is the type to retrieve from. Validator: pkg, npm or map.:name is the name of the package / import map. Validator: Comply with npm package names.:alias is the major version of the package / import map. Validator: Comply with semver validation regex.:extras whildcard pathname to any file in a package. Does not apply to import maps.  Status codes:  302 if alias exist404 if alias is not found  Example:  curl -X GET -L http://localhost:4001/pkg/fuzz/v8/main/index.js curl -X GET -L http://localhost:4001/map/buzz/v4   ","version":"Next","tagName":"h3"},{"title":"Create Alias​","type":1,"pageTitle":"HTTP API","url":"/docs/server/http-api#create-alias","content":" Method: PUT  Create a new alias.  https://:assetServerUrl:port/:type/:name/v:alias   URL parameters:  :type is the type to retrieve from. Validator: pkg, npm or map.:name is the name of the package / import map. Validator: Comply with npm package names.:alias is the major version of the package / import map. Validator: Comply with semver validation regex.  Form parameters:  :version full version of the package to be aliased  HTTP headers:  Authorization a jwt authorization bearer with the token retrieved from a successful authentication  Status codes:  303 if alias is successfully created. location points to the alias400 if validation in URL parameters or form fields fails401 if user is not authorized409 if alias already exist502 if alias could not be altered by the sink  Example:  curl -X PUT -i -F version=8.4.1 -H &quot;Authorization: Bearer {:token}&quot; http://localhost:4001/pkg/fuzz/v8 curl -X PUT -i -F version=4.2.2 -H &quot;Authorization: Bearer {:token}&quot; http://localhost:4001/map/buzz/v4   ","version":"Next","tagName":"h3"},{"title":"Update Alias​","type":1,"pageTitle":"HTTP API","url":"/docs/server/http-api#update-alias","content":" Method: POST  Updates an existing alias.  https://:assetServerUrl:port/:type/:name/v:alias   URL parameters:  :type is the type to retrieve from. Validator: pkg, npm or map.:name is the name of the package / import map. Validator: Comply with npm package names.:alias is the major version of the package / import map. Validator: Comply with semver validation regex.  Form parameters:  :version full version of the package to be aliased  HTTP headers:  Authorization a jwt authorization bearer with the token retrieved from a successful authentication  Status codes:  303 if alias is successfully created. location points to the alias401 if user is not authorized404 if alias does not exist502 if alias could not be altered by the sink  Example:  curl -X POST -i -F version=8.4.1 -H &quot;Authorization: Bearer {:token}&quot; http://localhost:4001/pkg/fuzz/v8 curl -X POST -i -F version=4.4.2 -H &quot;Authorization: Bearer {:token}&quot; http://localhost:4001/map/buzz/v4   ","version":"Next","tagName":"h3"},{"title":"Delete Alias​","type":1,"pageTitle":"HTTP API","url":"/docs/server/http-api#delete-alias","content":" Method: DELETE  Deletes an existing alias.  https://:assetServerUrl:port/:type/:name/v:alias   URL parameters:  :type is the type to retrieve from. Validator: pkg, npm or map.:name is the name of the package / import map. Validator: Comply with npm package names.:alias is the major version of the package / import map. Validator: Comply with semver validation regex.  HTTP headers:  Authorization a jwt authorization bearer with the token retrieved from a successful authentication  Status codes:  204 if alias is successfully deleted401 if user is not authorized404 if alias does not exist502 if alias could not be altered by the sink  Example:  curl -X DELETE -H &quot;Authorization: Bearer {:token}&quot; http://localhost:4001/pkg/fuzz/v8 curl -X DELETE -H &quot;Authorization: Bearer {:token}&quot; http://localhost:4001/map/buzz/v4  ","version":"Next","tagName":"h3"},{"title":"Metrics","type":0,"sectionRef":"#","url":"/docs/server/metrics","content":"","keywords":"","version":"Next"},{"title":"Usage​","type":1,"pageTitle":"Metrics","url":"/docs/server/metrics#usage","content":" You access the metrics stream on the .metric property of the Eik service. In this example we'll set up an endpoint so Prometheus can periodically fetch the metrics.  tip The metrics stream isn't tied specifically to Prometheus. See the MetricsJS documentation to learn how to consume these metrics if you don't use Prometheus.  import MetricsConsumer from &quot;@metrics/prometheus-consumer&quot;; import prometheus from &quot;prom-client&quot;; import Service from &quot;@eik/service&quot;; import fastify from &quot;fastify&quot;; const service = new Service(); const metricsConsumer = new MetricsConsumer({ client: prometheus, }); service.metrics.pipe(metricsConsumer); const app = fastify(); app.register(service.api()); app.get(&quot;/_/metrics&quot;, (request, reply) =&gt; { reply.type(metricsConsumer.registry.contentType); reply.send(metricsConsumer.registry.metrics()); }); const run = async () =&gt; { await service.health(); await app.listen({ port: service.config.get(&quot;http.port&quot;), host: service.config.get(&quot;http.address&quot;), }); }; run();   ","version":"Next","tagName":"h2"},{"title":"Available metrics​","type":1,"pageTitle":"Metrics","url":"/docs/server/metrics#available-metrics","content":" Each metric provided by the server has a unique name and a type defining what type (counter, histogram, etc) of metric it is.  The server exposes these metrics.  Name\tType\tDescriptioneik_core_auth_post_handler\thistogram\tTime taken in a login method eik_core_pkg_get_handler\thistogram\tTime taken in a public package method eik_core_pkg_log_handler\thistogram\tTime taken in a package version overview method eik_core_pkg_put_handler\thistogram\tTime taken in a upload package method eik_core_versions_get_handler\thistogram\tTime taken in a latest package versions method eik_core_alias_get_handler\thistogram\tTime taken in a public alias method eik_core_alias_put_handler\thistogram\tTime taken in a create alias method eik_core_alias_post_handler\thistogram\tTime taken in a update alias method eik_core_alias_del_handler\thistogram\tTime taken in a delete alias method eik_core_map_get_handler\thistogram\tTime taken in a public import maps method eik_core_map_put_handler\thistogram\tTime taken in a upload import maps method ","version":"Next","tagName":"h2"}],"options":{"id":"default"}}